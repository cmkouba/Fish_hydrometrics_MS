---
title: Supplement to "A watershed-specific formula to predict salmon reproduction using functional flow metrics"
author: "Claire Kouba, Jason Wiener, Leland Scantlebury and Thomas Harter"
date: "Feb. 2025"
output: 
  bookdown::word_document2: 
    fig_caption: true
    number_sections: true
    global_numbering: true
bibliography: draft_library.bib
---

```{r supp_setup_dirs_load_data, include = FALSE}


knitr::opts_chunk$set(echo = TRUE)

# dev_mode = run by itself; dev_mode = F if you are calling it from the main .Rmd
dev_mode = T

if(dev_mode){
  # libraries
  library(lubridate)
  library(httr)
  library(ggplot2) # for barplots 
  library(gridExtra)
  library(corrplot)  # for data exploration/correlation plots
  library(dataRetrieval) # for usgs data
  library(data.table) #month function
  library(zoo) # rolling means
  library(sf)
  library(terra)
  library(tmap)
  library(grid) # for inset maps
  library(cowplot) # for inset maps
  library(ggthemes) # for colorblind palette
  library(flextable)
  library(glmnet) # lasso regression
  library(MARSS)
  library(here)
  
  # Directories
  ms_dir = here::here()
  scratch_dir = file.path(ms_dir, "scratch_work")
  data_dir = file.path(ms_dir, "Data")
  graphics_dir = file.path(ms_dir, "Graphics and Supplements")
  
  # Load spatial and tabular data
  
  # If the data files don't exist locally,
  # pull data from internet and local files
  if(!file.exists(file.path(ms_dir,"manuscript_data.RData"))){
    source(file.path(ms_dir,"01_DataRetrieval_Cleaning_SaveLocal.R")) 
  }
  
  load(file.path(ms_dir, "manuscript_data.RData")) # Load data layers/tables
  source(file.path(ms_dir,"02_Figure_Functions.R"))   # Load figure and table functions
  
  # Save figures as images, yes or no?
  save_figs_here = graphics_dir
  # save_imgs=T # generate the figures in the folder
  include_figs = T
  replace_setting_fig = F # setting to F can save time if no need to re-render map
  fig_i = 1
  
  # pick last water year for the HB function to calculate a value for
  last_wy = 2023
}

```

```{r lassoRegYVal, echo = F}
predict_eco = "juvenile abundance, hydro and spawners"# "juveniles per spawner"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```

```{r supp_load_FF_metrics, include = FALSE}

if(dev_mode){
  log_transform_eco_metrics = T
  zscore_flow_metrics = T
  fflows = read_fflows_FJ(calculator = "Flashy")
  # fflows = read_fflows_FJ(calculator = "Regular")
  
  # produce metrics_tab
  
  brood_year_hydro_tab = tabulate_hydro_by_affected_brood_year(brood_years = 1999:2022,
                                                               smolt_years = 2001:2024)
  thresh_for_corr_fig = c(20,40,120)
  
  metrics_tab = calc_metrics_hydro_by_affected_brood_year(
    hydro_by_brood_year = brood_year_hydro_tab,
    thresholds = thresh_for_corr_fig) 

    metrics_tab_untransformed = metrics_tab # save a copy for supplemental tables
  
  # Clean metrics tab:
  # 1) factorize water year category
  metrics_tab$wy1_WY_Cat = as.numeric(factor(metrics_tab$wy1_WY_Cat,
                                             levels = c("dry year", "mod year", "wet year")))
  metrics_tab$wy2_WY_Cat = as.numeric(factor(metrics_tab$wy2_WY_Cat,
                                             levels = c("dry year", "mod year", "wet year")))
  
  
  yvlt = y_val_label_tab()
  non_preds = c("brood_year", "smolt_year", yvlt$y_val)
  
  
  if(zscore_flow_metrics == T){
    zscore_these = !(colnames(metrics_tab) %in% non_preds)
    metrics_mean = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = mean, na.rm=T)
    metrics_sd = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = sd, na.rm=T)
    metrics_tab[,zscore_these] = apply(X = metrics_tab[,zscore_these],
                                       MARGIN = 2, FUN = zscore_column_na_rm)
    
    if(predict_eco == "juvenile abundance, hydro and spawners"){
      # add spawners as a z-scored predictor variable
      metrics_tab$coho_spawners_zscored =
        zscore_column_na_rm(x = metrics_tab$coho_spawner_abundance)
      metrics_tab$chinook_spawners_zscored =
        zscore_column_na_rm(x = metrics_tab$chinook_spawner_abundance)
      non_preds = c(non_preds, "coho_spawners_zscored", "chinook_spawners_zscored")
      
    }
  }
  
  # transform data
  if(log_transform_eco_metrics == T){
    metrics_tab[,yvlt$y_val] = log10(metrics_tab[,yvlt$y_val])
  }
  
  
  # identify which columns we should keep in our correlation analysis
  corr_tab_all_metrics = cor(metrics_tab, use = "pairwise.complete.obs",
                             method = "spearman")
  ctl = collinear_screening_exercise(metrics_tab = metrics_tab,
                                     corr_tab_all_metrics = corr_tab_all_metrics,
                                     return_tab = "corr_tab_long_screened")
  
  keepers_co = c(non_preds, as.character(unique(ctl$Var1)))
  metrics_tab_screened = metrics_tab[,keepers_co]
  
  # Addl screening for temporal relevance to Chinook freshwater period
  metrics_before_chinook_outmigrate = 
    colnames(metrics_tab_screened) %in% non_preds |
    grepl(pattern = "d1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "f1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "w1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "s1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "wy1", x = colnames(metrics_tab_screened)) 
  keepers_ch = intersect(x = keepers_co, colnames(metrics_tab_screened)[metrics_before_chinook_outmigrate])
  
  metrics_tab_screened_chinook = metrics_tab_screened[,keepers_ch]
  
  # if(predict_eco == "juvenile abundance, hydro and spawners"){
    screened_cols = c(keepers_co, "coho_spawners_zscored","chinook_spawners_zscored")
    screened_cols_ch = c(keepers_ch, "coho_spawners_zscored","chinook_spawners_zscored")
  # }
  
  preds_screened = screened_cols[!(screened_cols %in% non_preds)]
  # metrics_tab_screened = metrics_tab[,screened_cols]
  # metrics_tab_screened_chinook = metrics_tab[,screened_cols_ch]
  
  
}
```


# Supplement to "A watershed-specific formula to predict salmon reproduction using functional flow metrics" {-}

# Overview of research on flow-ecology relationships

Work on this topic of quantifying ecological responses to changes in flow spans multiple categories of ecological response, hydrologic predictor, and ultimate cause of hydrologic alteration. Two widely studied ecological response metric categories are, firstly, the stream health index, based on density and species richness of macroinvertebrates observed at designated sampling sites [e.g., @MonkEtAlFlow2006; @GuareschiEtAlHow2014; @KevicEtAlEffects2018; @MazorEtAlTools2018; @LarsenEtAlCombining2021; @PeekEtAlIdentifying2022], and secondly, fish diversity and community assemblage [e.g., @McManamayEtAlApplication2013; @PetersonFreemanIntegrating2016; @CartwrightEtAlPutting2017; @SinnathambyEtAlEcohydrological2018; @HainEtAlUsing2018; @GuedesEtAlArtificial2020; @YaoEtAlIdentifying2021]. Ecological responses can also be based on the abundance of a single or a few species, often of fish [@Stewart-KosterEtAlFish2011; @BoothEtAlDetermining2014; @DeWeberPetersonComparing2020; @HaleEtAlMy2023], as well as the extent of habitat types [@ChowdhuryDriverEcohydrological2007; @ArrianaBrandEtAlProjecting2011] and the presence of organisms including vegetation and plankton [@RiisEtAlVegetation2008; @CatfordEtAlSpecies2014; @QianEtAlEffects2016; @TesfayeEtAlClimatic2017; @SabyEtAlSensitivity2022]. Hydrologic predictors range widely, with a heavy emphasis on extreme (low or high) flow events and the duration of components of the flow regime [e.g., @AyllonEtAlSpatiotemporal2014; @LamourouxOlivierTesting2015; @McManamayFrimpongHydrologic2015; @BowerEtAlQuantifying2022]. Alteration from a natural flow regime is a widely-used framework for calculating hydrologic predictors [@RichterEtAlMethod1996; @PoffEtAlEcological2010]. Causes of the change in hydrology include the operation of dams, changes in human water use, climate change, and natural flow variability [e.g., @AlomiaHerreraCarreraBurneoEnvironmental2017; @GaoEtAlHydrological2020; @WhiteEtAlMacroinvertebrate2018; @DaneshvarEtAlResponse2017; @HerbstEtAlDrought2019]. 

Investigations of flow-ecology relationships can also be grouped by approach [as in @TharmeGlobal2003; @BrummerEtAlQuantitative2016]. In experimental flow studies the flow is directly manipulated with dam releases and biological responses are monitored [e.g., @KonradEtAlLargescale2011]. In longitudinal studies, long-term ecological and hydrological records can be used to infer local or regional correlations [e.g., @Mellado-DiazEtAlExploring2019]. Finally, in space-for-time approaches, the hydrology of multiple river systems in a region is used to populate the distribution of different hydrologic behavior, and ecological monitoring is related to flow differences between streams [e.g., @MonkEtAlMacroinvertebrate2008; @RiisEtAlVegetation2008; @CatfordEtAlSpecies2014; @BowerEtAlQuantifying2022]. Space-for-time analyses require considerably fewer resources than experimental flows and longitudinal studies, and thus are more numerous [@BrummerEtAlQuantitative2016]. 


<!-- ## Previous work and limitations of a hydrologic predictor approach -->

<!-- In many previous studies of flow-ecology relationships (especially related to fisheries), predictors used to model the ecological response are flow-derived metrics, because flow data is often continuous and more abundant than other data types. Such models rely on the assumption that flow, directly or as a proxy for other variables (e.g., habitat) is the limiting factor in ecological recruitment, and thus that changes in flow can be directly translated to a population response. However, this ignores ecological theory. Under many circumstances, complex internal population feedbacks (such as high juvenile fish density leading to some juvenile fish mortality) or community dynamics (food webs) will be the limiting factors on fish population size. Consequently, many authors have argued that models of fish population responses to hydrologic changes should explicitly include ecological population modeling in addition to physical factors such as flow or geomorphology [@RosenfeldAssessing2003; @AndersonEtAlInstream2006; @LancasterDownesLinking2010; @AcremanEtAlEnvironmental2014; @ShentonEtAlPutting2012]. Additionally, in at least one case, fish population differences were not successfully predicted with a model based only on flow metrics; other variables such as water temperature were necessary to capture population shifts [@McManamayEtAlApplication2013]. -->

<!-- In spite of these known limitations, the HB function proposed here uses only hydrologic predictors. In part this is a pragmatic approach, as this work is intended to set the foundation for assessing flow conditions in speculative hydrologic models, which do not simulate non-hydrologic, ecologically-relevant factors such as water quality or internal population dynamics. Furthermore, previous work suggests that seasonal flow availability is a major limiting factor on the local coho salmon fishery, supporting the hydrologic predictor only approach in this case [SRWC and Siskiyou RCD -@ScottRiverWatershedCouncilLimiting2005; NMFS -@NationalMarineFisheriesServiceFinal2014].  -->

<!-- Lastly, the proposed HB function avoids some of the disadvantages of the snapshot method of comparing the two states of natural and altered flows [@WheelerEtAlStates2018], because the hydro-ecological dataset is relatively long. This temporal structure, covering a wide range of water year types, makes it possible to test the hypothesis that a measurable relationship exists between hydrologic signal and ecologic response, even within an otherwise more complex relationship involving many non-hydrologic factors. -->


# Brief history of Scott River water use, management, and investigations

Water in Scott Valley is used for agricultural, domestic, and municipal supply. It also facilitates recreation and provides Native American cultural services, among other designated beneficial uses [NCRWQCB -@NorthCoastRegionalWaterQualityControlBoardACTION2006]. Because the watershed is undammed, managers and water users influence Scott River flow primarily via diversion of surface waters and pumping of groundwater. Consequently, the most powerful tool available to manage Scott River water flow is regulation of land use and thus water demand [Siskiyou County -@SiskiyouCountyScott2021]. This summary focuses on work relevant to the current study; for a more comprehensive list of natural resource work in the region see the library at @SiskiyouResourceConservationDistrictSiskiyou2025.

Historically, local regulation of land use has focused on maintaining the rural and agricultural character of Scott Valley [@ScottValleyAreaPlanCommitteeScott1980]. Regulating land use to improve ecological outcomes would entail significant economic, political and social risks, because much of the economic activity in this area is related to agriculture. The primary crops grown in Scott Valley are pasture for cattle feed and alfalfa [Siskiyou County -@SiskiyouCountyScott2021]. In addition to local economic impact, Scott River conditions influence fish population dynamics both within the watershed and in the broader Klamath system. The health of the Klamath salmon run has implications for commercial fishing, recreational activities, and cultural practices of Native American tribes in the region, including the Quartz Valley Indian Community and the Karuk and Yurok Tribes [@MansfieldEtAlKlamath2012].

Recent management activity has included the leasing of surface water rights from landowners to enhance summer flows [e.g., SRWT -@Magranet20172018], the prioritization of stream reaches for habitat restoration [SRWC -@ScottRiverWatershedCouncilRestoring2018], several pilot projects to construct and assess the impact of beaver dam analogs (BDAs) on aquatic habitat and fish populations [Yokel -@YokelEtAlScott2018], a coordinated rescue effort to relocate juvenile salmon that were cut off from outmigrating by disconnected river reaches [CDFW -@CaliforniaDepartmentofFishandWildlifeEtAlCooperative2015], and the development of long-term groundwater management plan by Siskiyou County and local stakeholders [Siskiyou County -@SiskiyouCountyScott2021].

Although the empirical "flow-to-ecology" link described above has not been quantified, flow-ecology relationships have been investigated by multiple entities in the Scott River Watershed. Over the past three decades, several organizations and agencies have conducted extensive monitoring and published a series of reports and plans regarding the salmon fisheries in the Scott River watershed. In the 1990s, fall flows in the Scott River were reported to be too low in some years to allow for Chinook spawning in September-November [CRMP and SRWC -@CoordinatedResourceManagementPlanningCommitteeScottRiverWatershedCouncilFINAL2000], but in the mid-2000s it was reported that low fall flows rarely affected the later (November-January) spawning runs of steelhead and coho salmon [SRWC and Siskiyou RCD -@ScottRiverWatershedCouncilSiskiyouResourceConservationDistrictInitial2005]. More recently, fall flows have affected coho salmon as well as Chinook, as the late onset of winter storms has delayed coho spawning in some water years [e.g., CDFW -@CaliforniaDepartmentofFishandWildlifeEtAlCooperative2015]. In the mid-2000s, a local conservation organization identified the lack of suitable summer and winter rearing habitat as a probable limitation on Scott River coho smolt production [SRWC and Siskiyou RCD -@ScottRiverWatershedCouncilLimiting2005]. Several years later, in a NOAA Fisheries Coho Recovery Plan, NMFS identified the juvenile life stage as the most limited in the population [NMFS -@NationalMarineFisheriesServiceFinal2014]. 


# Species of concern - coho and Chinook salmon

### Life cycle and status of coho salmon (*Oncorhynchus kisutch*)

Returning adult coho spawn in natal streams between November and January [@KnechtleGiudice20192020], and juvenile coho spend approximately one full year in freshwater streams before migrating to the ocean as smolts [@MoyleCoho2002; @McMahonHabitat1983]. In the Scott River system these natal streams are the tributaries along the margins of the valley floor [SRCD -@SiskiyouResourceConservationDistrictFinal2004].

In previous studies, the strongest predictor of juvenile coho abundance in a stream system was spatial habitat [@BradfordEtAlEmpirical1997; @NickelsonEtAlSeasonal1992; @BustardNarverAspects1975], although adequate food and cover were also important [@McMahonHabitat1983]. The primary mechanism for spatial constraints on abundance appears to be that juvenile coho become more territorial as they grow [@McMahonHabitat1983].

Some coho salmon return to spawn at age 2 as grilse, but the majority (e.g., 92.4% in 2020) return after more than one year in the ocean, giving the Scott coho salmon run its characteristic 3-year cohort return interval [@KnechtleGiudice20192020].

Coho salmon in the Scott Valley are listed as threatened under the federal and California Endangered Species Acts (ESAs). They belong to the Southern Oregon / Northern California Coast (SONCC) Evolutionarily Significant Unit (ESU), which was listed as threatened under the federal and state ESAs in 1997 and 2005, respectively. State-wide, coho populations have declined more than 90% since the 1940s [@BrownEtAlHistorical1994]. 

### Life cycle and status of Chinook salmon (*Onchorhynchus tsawytscha*)

Chinook salmon in the Scott Valley are a candidate for listing under the federal ESA, and are not listed under the California ESA. They belong to the Southern Oregon / Northern California Coast (SONCC) Evolutionarily Significant Unit (ESU). 
Typically, adult Chinook salmon return to spawn in Scott Valley streams in the fall months September-December when flows are sufficient for salmon passage [@KnechtleGiudice20192020; @MagranetScott2015a; @MagranetScott2017]. Chinook in this watershed hatch in the spring and migrate to the ocean in their first year of life [@AgrawalEtAlPREDICTING2005]. Chinook spend the majority of their life in the ocean, and return to their natal streams shortly before spawning [@GrootMargolisLife1991]. However, substantial variability exists within this broader structure: Chinook salmon exhibit variation in multiple life stages, including time of seaward migration, age of maturity, and timing of return to natal stream [@GrootMargolisLife1991; @BourretEtAlDiversity2016].

As recently as 2013, the SONCC Chinook population was stable and becoming more complex [@WainwrightEtAlCCIEA2013]. However, in monitoring from 2015-2020, the number of returning adults (the escapement) was 65% below historical average, and the change in the Scott River Chinook population has been more rapid than the decline in the overall Klamath Basin Chinook run [@CaliforniaDepartmentofFishandWildlifeScott2021]. Ocean conditions may have contributed to a broad decline in Chinook populations from Alaska to California [@WelchEtAlSynthesis2021]. Some studies have found that the leading cause of declining Chinook populations are ocean conditions, including including temperature, upwelling currents and food resources [@HuntEtAlOceanic1999], while others have identified hatchery practices as the primary cause [@QuinonesEtAlPotential2014]. 


# Hydrologic Metrics

## Functional Flows Background 

The annual functional flow metrics calculated from Fort Jones average daily flow (USGS Gauge `r fj_num`) [@PattersonEtAlHydrologic2020; @CarpenterAccurately2024] are shown in Tables \@ref(tab:funcFlowsAnnualValuesTab1) through \@ref(tab:funcFlowsAnnualValuesTab6) below. These are then aligned with a salmon cohort for the statistical modeling exercise.

```{r funcFlowTermsTab, echo = FALSE, results = 'asis'}

ff_tab = read.csv(file.path(data_dir,"Hydro Metrics Table_Functional Flows.csv"))

#Create caption and column labels
caption_text = "Explanation of functional flows used in this analysis (Patterson et al. 2020; Carpenter 2024; Baruch et al. 2024). Each type of metric, for each threshold value (e.g., 100 cfs or 50th flow percentile), produces one value per water year."
column_labels = c("Abbrev.","Full Name", "Thresholds","Description")
colnames(ff_tab) = column_labels

ff_tab_ft = flextable(data=ff_tab)
ff_tab_ft = set_caption(ff_tab_ft, caption = caption_text)
ff_tab_ft = flextable::width(ff_tab_ft,j=1,  width = 1.3)
ff_tab_ft = flextable::width(ff_tab_ft,j=2,  width = 1.5)
ff_tab_ft = flextable::width(ff_tab_ft,j=3, width = 1)
ff_tab_ft = flextable::width(ff_tab_ft,j=4,  width = 3.1)
ff_tab_ft

``` 

<!-- fig.id="faithfuld-plot2", fig.cap.pre="Supplementary Figure",fig.lp="supp-fig" -->

```{r fig2Yarnell2020,  echo = F, warning =F, message = F, fig.height = 8.5, fig.cap = "Figure 2 from Yarnell et al., 2020. Illustration of five functional flow categories identified for a mixed rain-snowmelt runoff river in California."}

if(save_imgs==T){
  file.copy(from = file.path(graphics_dir, "Graphics source", "Yarnell2020_Fig2.png"),
            to = file.path(save_figs_here, paste0("Figure S",fig_i,".png")))
}

if(include_figs==T){
  knitr::include_graphics(file.path(save_figs_here, paste0("Figure S",fig_i,".png")))
}


fig_i = fig_i +1

```

\newpage


## Data tables: annual values for Fort Jones Gauge functional flows

```{r funcFlowsAnnualValuesTab1, echo = FALSE, results = 'asis'}

flash_tab = read.csv(file.path(data_dir,"ScottR_FJ_wy1942_2025.01.21_annual_Flashy_Calc.csv"))
#Create caption and column labels
flash_tab$Year=as.character(flash_tab$Year)
col_1 = 1; col_2 = col_1+6

caption_text = paste0("Functional Flows calculated for Scott River Gauge ",fj_num,", columns ",col_1," through ",col_2, " of ", ncol(flash_tab), ", using the Flashy Calculator (Carpenter 2024).")

ft_ft = flextable(data=flash_tab[,col_1:col_2])
ft_ft = set_caption(ft_ft, caption = caption_text)
ft_ft = colformat_double(ft_ft, j = 4:5, digits = 1)
ft_ft = flextable::width(ft_ft,j=c(2,4,5),  width = 1)
ft_ft

```  
\newpage


```{r funcFlowsAnnualValuesTab2, echo = FALSE, results = 'asis'}
col_1 = col_2; col_2 = col_1+5

caption_text = paste0("Functional Flows calculated for Scott River Gauge ",fj_num,", columns ",col_1," through ",col_2, " of ", ncol(flash_tab), ", using the Flashy Calculator (Carpenter 2024).")

ft_ft = flextable(data=flash_tab[,c(1,col_1:col_2)])
ft_ft = set_caption(ft_ft, caption = caption_text)
ft_ft = colformat_double(ft_ft, j = 4, digits = 1)
ft_ft = colformat_double(ft_ft, j = 5:6, digits = 3)
ft_ft = flextable::width(ft_ft,j=c(4:6),  width = 1)
ft_ft

```  

\newpage

```{r funcFlowsAnnualValuesTab3, echo = FALSE, results = 'asis'}
col_1 = col_2; col_2 = col_1+6

caption_text = paste0("Functional Flows calculated for Scott River Gauge ",fj_num,", columns ",col_1," through ",col_2, " of ", ncol(flash_tab), ", using the Flashy Calculator (Carpenter 2024).")

ft_ft = flextable(data=flash_tab[,c(1,col_1:col_2)])
ft_ft = set_caption(ft_ft, caption = caption_text)
ft_ft = colformat_double(ft_ft, j = 6, digits = 1)
# ft_ft = colformat_double(ft_ft, j = 4:5, digits = 3)
ft_ft = flextable::width(ft_ft,j=c(5:7),  width = 1)
ft_ft

```

\newpage

```{r funcFlowsAnnualValuesTab4, echo = FALSE, results = 'asis'}
col_1 = col_2; col_2 = col_1+5

caption_text = paste0("Functional Flows calculated for Scott River Gauge ",fj_num,", columns ",col_1," through ",col_2, " of ", ncol(flash_tab), ", using the Flashy Calculator (Carpenter 2024).")

ft_ft = flextable(data=flash_tab[,c(1,col_1:col_2)])
ft_ft = set_caption(ft_ft, caption = caption_text)
# ft_ft = colformat_double(ft_ft, j = 5, digits = 1)
# ft_ft = colformat_double(ft_ft, j = 4:5, digits = 3)
ft_ft = flextable::width(ft_ft,j=c(3:7),  width = 1)
ft_ft

```

\newpage

```{r funcFlowsAnnualValuesTab5, echo = FALSE, results = 'asis'}
col_1 = col_2; col_2 = col_1+5

caption_text = paste0("Functional Flows calculated for Scott River Gauge ",fj_num,", columns ",col_1," through ",col_2, " of ", ncol(flash_tab), ", using the Flashy Calculator (Carpenter 2024).")

ft_ft = flextable(data=flash_tab[,c(1,col_1:col_2)])
ft_ft = set_caption(ft_ft, caption = caption_text)
# ft_ft = colformat_double(ft_ft, j = 5, digits = 1)
# ft_ft = colformat_double(ft_ft, j = 4:5, digits = 3)
ft_ft = flextable::width(ft_ft,j=c(2:3,7),  width = 1)
ft_ft

```

\newpage

```{r funcFlowsAnnualValuesTab6, echo = FALSE, results = 'asis'}
col_1 = col_2; col_2 = ncol(flash_tab)

caption_text = paste0("Functional Flows calculated for Scott River Gauge ",fj_num,", columns ",col_1," through ",col_2, " of ", ncol(flash_tab), ", using the Flashy Calculator (Carpenter 2024).")

ft_ft = flextable(data=flash_tab[,c(1,col_1:col_2)])
ft_ft = set_caption(ft_ft, caption = caption_text)
ft_ft = colformat_double(ft_ft, j = 5, digits = 1)
# ft_ft = colformat_double(ft_ft, j = 4:5, digits = 3)
ft_ft = flextable::width(ft_ft,j=c(2:5),  width = 1)
ft_ft

```


\newpage


## Hydrologic Metrics Designed for This Study

```{r customHydroMetricsTab, echo = FALSE, results = 'asis'}

ff_tab = read.csv(file.path(data_dir,"Hydro Metrics Table_Custom metrics.csv"))
ff_tab = ff_tab[1:2,]
#Create caption and column labels
caption_text = "Explanation of custom hydrologic metrics designed for this study, which are less complex than functional flows in that they do not rely on signal processing techniques. Each type of metric, for each threshold value (e.g., 120 cfs), produces one value per water year. Metric names used in predictive modeling also include abbreviations for salmon life periods (defined in Methods section); e.g., f1_recon_120, referring to the timing of flow exceeding 120 cfs in a cohort's first fall season (f1)."
column_labels = c("Abbrev.","Full Name", "Thresholds","Description")
colnames(ff_tab) = column_labels

ff_tab_ft = flextable(data=ff_tab)
ff_tab_ft = set_caption(ff_tab_ft, caption = caption_text)
ff_tab_ft = flextable::width(ff_tab_ft,j=1,  width = 1.1)
ff_tab_ft = flextable::width(ff_tab_ft,j=2,  width = 1.5)
ff_tab_ft = flextable::width(ff_tab_ft,j=3, width = 1)
ff_tab_ft = flextable::width(ff_tab_ft,j=4,  width = 3.2)
ff_tab_ft

```  


```{r reconnectExplainerHydrograph, echo = F, warning =F, message = F, fig.cap = "Reconnection and disconnection dates are highlighted for one water year. Two example thresholds, 20 and 120 cfs (0.57 and 3.4 cms, respectively) are highlighted, which correspond to distinct river connectivity (and salmon habitat access) conditions in the Scott River watershed as observed at the Fort Jones gauge (see Results for more detail on selection of flow thresholds)."}


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 4.5, units = "in", res = res_dpi)
  
  recon_and_discon_explainer_hydrograph(
    water_year = 2016, tot_flow_annotate = F, 
    connection_date_annotate = "20_and_120_only")
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```

## Screening Predictors for Collinearity

```{r predCorrScreeningTable, echo = F, warning =F, message = F, comment = F}

# Calculate correlation matrix
corr_tab_all_metrics = cor(metrics_tab, use = "pairwise.complete.obs",
                           method = "spearman")

elim_pred_tab = collinear_screening_exercise(metrics_tab = metrics_tab,
                                             corr_tab_all_metrics = corr_tab_all_metrics)
elim_pred_tab$ID = 1:nrow(elim_pred_tab)
elim_pred_tab = elim_pred_tab[ ,
                  c("ID", colnames(elim_pred_tab)[colnames(elim_pred_tab) != "ID"])]

caption_text = "Groups of collinear predictors (absolute value of R greater than 0.7), interpretation of their hydrologic significance, and the predictor selected from each group to reduce collinearity."

column_labels = c("ID","Group of Collinear Predictors","Hydrologic Significance (Coho Life Stage)",
                  "Predictor Selected from Group")
colnames(elim_pred_tab) = column_labels

ept_tab_ft = flextable(data=elim_pred_tab)
ept_tab_ft = set_caption(ept_tab_ft, caption = caption_text)
ept_tab_ft = flextable::width(ept_tab_ft,j=2,  width = 2.8)
ept_tab_ft = flextable::width(ept_tab_ft,j=3,  width = 2)
ept_tab_ft = flextable::width(ept_tab_ft,j=4,  width = 1.5)
ept_tab_ft
```

### Groups 1 and 2

These metrics describe the magnitude and timing of wet-season flows (years 1 and 2), as well as (for `w1`) conditions during the following dry season, which can be summarized by the question, 'how wet was the wet season?' We selected median wet season flows `w1_Wet_BFL_Mag_50` and `w2_Wet_BFL_Mag_50` as the most conceptually central metric to represent the amount of water passing through the watershed. Seasons `w1` and `w2` are experienced by a coho cohort as eggs and newly-hatched alevin and fry, and as overwintering parr, respectively.

### Group 3

These metrics describe the magnitude and timing of dry-season and end-of-dry-season flows before the cohort's spawning. We selected the dry season median flow, `d1_DS_Mag_50`, as the most conceptually central metric to represent the amount of water passing through the watershed during the dry season before a cohort's parents' spawning.

### Groups 4, 5 and 7

These metrics relate to the timing of the transition from dry to wet season in year 2 (Group 4) and year 1 (Groups 5 and 7). We selected `w2_Wet_Tim` and `w1_Wet_Tim`, the timing of the wet season onset. In `w1` and `w2`, hydrology is experienced by a cohort of coho as eggs or new hatchlings and overwintering juveniles, respectively.

### Groups 6 and 8

These metrics quantify the magnitude of the fall pulse flow (years 1 and 2), with two similar metrics: `FA_Mag`, with a tighter definition of a fall pulse flow (and missing values for years in which these fall pulse criteria are not met), and `FA_Dif_num`, with a looser definition (and no missing values). We selected the fall flow increase `FA_dif_num` [from @BaruchEtAlMimicking2024] for both `f1` and `f2`.


# Ecological Data Features


## Sources and methods


```{r ecoMetricsMonitoringTab, echo = FALSE, results = 'asis'}

em_tab = read.csv(file.path(data_dir,"Ecological Monitoring Data Source Information.csv"))

#Create caption and column labels
caption_text = "Description and source information for ecological observations of the two salmonid species of concern."
column_labels = c("Obs. ID","Abbrev.","Description", "Monitoring Details", "Source(s)", "Predictor Seasons")
colnames(em_tab) = column_labels

em_tab_ft = flextable(data=em_tab)
em_tab_ft = set_caption(em_tab_ft, caption = caption_text)
em_tab_ft = flextable::width(em_tab_ft,j=1,  width = .5)
em_tab_ft = flextable::width(em_tab_ft,j=2,  width = 1.5)
em_tab_ft = flextable::width(em_tab_ft,j=3, width = 1.5)
em_tab_ft = flextable::width(em_tab_ft,j=4,  width = 1.5)
em_tab_ft = flextable::width(em_tab_ft,j=5,  width = 1.2)
em_tab_ft = flextable::width(em_tab_ft,j=6,  width = 0.7)
em_tab_ft

```  


## Autocorrelation in ecological records

Autocorrelation, with a lag of 3, is evident in two ecological records: the abundances of coho redds and coho smolt (Figure \@ref(fig:acfEcoRecords)). In other words, the 3-year-lagged record of coho smolt approaches, and for redds exceeds, the 95% confidence interval that it is not random noise. 

Interestingly, for coho spawner abundance, although the sign of the autocorrelation is positive at 3 and 6 year lags (which we would expect, reflecting the cohort structure), autocorrelation in the coho spawner record is weaker than in the redd and smolt records. 

No significant autocorrelation is evident in the three Chinook data types, and none is observed for coho smolt per female. 

```{r acfEcoRecords, echo = F, warning = F, fig.height = 8, fig.cap = "Autocorrelation function estimates for all available ecological outcome records.\\label{fig:acfEcoRecords}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

par(mfrow = c(3,3))
for(i in 1:nrow(yvlt)){
  y_i = yvlt$y_val[i]
  y_vals_continuous = get_longest_cont_ts(y = metrics_tab[,y_i], 
                                          y_years = metrics_tab$brood_year)
  acf(x = y_vals_continuous$y_cont,
      main = yvlt$y_val_label[i],
      sub = paste0("Continuous record length: ",nrow(y_vals_continuous), " years"))
  legend(x = "topright", bty = "n", legend = LETTERS[i])
}


if(save_imgs == TRUE){dev.off()}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1
```

# Data tables: Alignment of predictor and response data

The aligned hydrologic predictor and ecological response data are shown in Tables \@ref(tab:hydroAndEcoTab1) through \@ref(tab:hydroAndEcoTab12) below. The first eight columns (Table \@ref(tab:hydroAndEcoTab1)) are composed of ecological responses observed for each brood year. The remaining 72 columns tabulate the functional flow and other hydrologic metrics, covering two years of coho salmon freshwater life stages, associated with each brood year. As discussed in methods, the seasonal abbreviations d1, f1, w1, s1, d2, f2, w2 and s2 indicate the season (first or second dry, fall, wet, or spring) in which or coho salmon cohort would experience the hydrology quantified in a given metric. (Juvenile Chinook salmon experience only one year of freshwater conditions before outmigrating.)

\newpage 
```{r hydroAndEcoTab1, echo = FALSE, results = 'asis'}
mt_for_ft = metrics_tab_untransformed
mt_for_ft[,"smolt_year"] = NULL
mt_for_ft$brood_year = as.character(mt_for_ft$brood_year)
colnames(mt_for_ft) = gsub(pattern = "_", replacement = " ", x = colnames(mt_for_ft))

col_1 = 1; col_2 = 8
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")

met_ft = flextable(data=mt_for_ft[,col_1:col_2])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = flextable::colformat_double(met_ft,j=2,digits = 1)
met_ft = flextable::width(met_ft,j=c(4,7,8),  width = 1)
met_ft

``` 

\newpage  
```{r hydroAndEcoTab2, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft
``` 
\newpage

```{r hydroAndEcoTab3, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = 7:8, digits = 1)
met_ft
``` 

\newpage 
```{r hydroAndEcoTab4, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = c(5,7), digits = 1)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab5, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab6, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = 8, digits = 3)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab7, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = 2, digits = 3)
met_ft = colformat_double(met_ft, j = 6, digits = 0)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab8, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = c(3,4,8), digits = 1)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab9, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = 3, digits = 1)
met_ft
``` 

\newpage
```{r hydroAndEcoTab10, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab11, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = col_1+6
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = 4:5, digits = 3)
met_ft
``` 
 
\newpage
```{r hydroAndEcoTab12, echo = FALSE, results = 'asis'}
col_1 = col_2+1; col_2 = ncol(mt_for_ft)
caption_text = paste0("Hydrologic metrics and ecological observations aligned by brood year of each salmon cohort, columns ", col_1, " through ", col_2, " of 80.")
met_ft = flextable(data=mt_for_ft[,c(1,col_1:col_2)])
met_ft = set_caption(met_ft, caption = caption_text)
met_ft = colformat_double(met_ft, j = 2, digits = 0)
met_ft = flextable::width(met_ft, j = 3, width = 1.5)
met_ft
``` 

# Six statistical modeling structures - method details

**LASSO model of juveniles-per-spawner:** Cross-validation produced a clear minimum-error $\lambda$ value for Chinook (Figure \@ref(fig:jpsLassoCohoChinook)). For coho, we proposed an alternate lambda value that explained more percent deviance (Figure \@ref(fig:jpsLassoCohoChinook), middle left panel) while retaining a near-minimum test error (Figure \@ref(fig:jpsLassoCohoChinook), top left panel). This produced a model with three non-zero coefficients for both species (Figure \@ref(fig:jpsLassoCohoChinook), lower two panels; Tables \@ref(tab:jpsCoefTableCoho) and \@ref(tab:jpsCoefTableChinook))

**LASSO model of juvenile abundance, hydrology and spawners:** the selected predictors included spawners only for Chinook (Tables \@ref(tab:juvAbunCoefTableCoho) and \@ref(tab:juvAbunCoefTableChinook)). 

**Lasso model of juvenile abundance, hydrologic metrics only:** replicating the approach for the LASSO model of juveniles-per-spawner, we proposed an alternate lambda value for the coho model (Figure \@ref(fig:juvAbunHydOnlyLassoCohoChinook)). Selected predictors for coho were similar to the juvenile abundance, hydrology-plus-spawners LASSO model, while for Chinook, the minimum-error model selected only one predictor (Tables \@ref(tab:juvAbunHydOnlyCoefTableCoho) and \@ref(tab:juvAbunHydOnlyCoefTableChinook)). 

**MARSS models of juveniles-per-spawner, single hydrologic covariate:** hydrology order of importance is taken from the small-sample-size-corrected Akaike Information Criterion (AICc), i.e., the lower the AICc, the better the prediction based on that hydrologic metric (Tables \@ref(tab:MARSSSingleCovarTableCoho) and \@ref(tab:MARSSSingleCovarTableChinook)).

**MARSS models of juveniles abundance, single hydrologic covariate:** hydrology order of importance interpreted as described above (Tables \@ref(tab:MARSSSingleCovarTableCoho) and \@ref(tab:MARSSSingleCovarTableChinook)); this is used to test the utility of adding spawners as a covariate.

**MARSS models of juvenile abundance, two covariates:** This model structure calculates a coefficient value for spawners and for any single hydrologic metric (Tables \@ref(tab:MARSSFlowAndSpawnCovarTableCoho) and \@ref(tab:MARSSFlowAndSpawnCovarTableChinook)). For the four best models, hydrology coefficients are equal to or greater than coefficients for spawners. For worse, higher-AICc models, spawner influence grows to be much greater than the hydrology.

MARSS models tended to perform better at predicting coho than Chinook (Figures \@ref(fig:MARSSSingleCovars),  \@ref(fig:MARSSJuvAbunSingleCovars), and \@ref(fig:MARSSHydroPlusSpawn), possibly because Chinook records did not contain significant autocorrelation (Figure \@ref(fig:acfEcoRecords)). 

# LASSO regression 

LASSO (Least Absolute Shrinkage and Selection Operator) regression minimizes the following quantity:

$$\sum_{i=1}^{n}{(y_i-\beta_0-\sum_{j=1}^{p}{\beta_jx_{ij}})^2}+\lambda\sum_{j=1}^{p}{|\beta_j|}$$

Where:

* $n$ is the number of ecological observations;
* $i$ enumerates the brood years;
* $p$ is the number of predictors;
* $j$ enumerates the hydrologic predictors;
* $x_{ij}$ is the observed value of hydrologic predictor $j$ for brood year $i$ (independent variable);
* $y_i$ is the observed value of ecological response in the salmon cohort with brood year $i$ (dependent variable);
* $\beta_0$ is the intercept value for the resulting linear model;
* $\beta_j$ is the coefficient value for hydrologic predictor $j$ in the resulting linear model; and
* $\lambda$ is a tuning parameter, referred to as a shrinkage penalty.

In this formulation, sufficiently large values of lambda generally shrink the values of all coefficients to 0 (the infinite-lambda case). The infinite-lambda case produces a model consisting solely of the $\beta_0$ intercept term, which takes on a value that is the average of all the observed $y$ values. Conversely, sufficiently small values of $\lambda$ will produce linear models incorporating information from many predictors. 
The selection of the appropriate $\lambda$ value is a critical step in the regression procedure, and is best done using cross-validation within the training dataset [@JamesEtAlIntroduction2013].

## LASSO results: juveniles-per-spawner based on hydrologic metrics

For purposes of statistical model comparison, we predicted the ratio of juveniles per spawner for coho and Chinook based on a predictor set that included only Z-scored hydrologic metrics.

```{r alt_lasso_analysis_1, echo = FALSE, warning = F}

# calculate lasso regression model and cross-validation objects
# (lasso: alpha = 1; ridge: alpha = 0)\
predict_eco = "juveniles per spawner"
y_val_coho = "coho_smolt_per_fem"; y_val_chinook = "chinook_juv_per_adult"

if(predict_eco %in% c("juvenile abundance, hydro only", 
                      "juveniles per spawner")){
  mts_jho = metrics_tab_screened
  mts_jho[,c("coho_spawners_zscored", "chinook_spawners_zscored")] = NULL
  mts_jho_ch = metrics_tab_screened_chinook
  mts_jho_ch [,c("coho_spawners_zscored","chinook_spawners_zscored")] = NULL

  mod_obj_co = kfold_cv(mt = mts_jho,
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv(mt = mts_jho_ch, alpha =1,
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .15
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)

}





```


```{r jpsLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:juvAbunHydOnlyLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

if(predict_eco %in% c("juveniles per spawner",
                      "juvenile abundance, hydro only")){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch
                , alt_lambda_co = alt_lambda_co
                )
}

if(save_imgs == TRUE){
  dev.off()

}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r jpsCoefTableCoho, echo = F, warning =F, message = F, results = 'asis'}

# Retrieve coefficients from lasso model

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names


if(predict_eco == "juveniles per spawner"){
  # coefs_interp$d1_DS_Dur_WS = "Shorter dry season (preceding parents' spawning)"
  if("w1_Wet_Tim" %in% names(coefs_interp)){ coefs_interp$w1_Wet_Tim = "Earlier wet season onset (as eggs and fry)"  }
  if("f1_recon_120" %in% names(coefs_interp)){ coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"}
  if("f1_FA_Dif_num" %in% names(coefs_interp)){ coefs_interp$f1_FA_Dif_num = "Larger fall pulse (during parents' spawning)"}
  if("f2_FA_Dif_num" %in% names(coefs_interp)){coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"}
  # coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
  if("s1_SP_ROC" %in% names(coefs_interp)){coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"}
  # coefs_interp$w2_Wet_BFL_Mag_50 = "Lower wet season baseflow (as juvenile fish)"
  
}

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
                      yvlt$y_val_title[yvlt$y_val==y_val_coho]," based on hydrology only, including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 2)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r jpsCoefTableChinook, echo = F, warning =F, message = F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
# if(predict_eco == "juvenile abundance, hydro only"){
#   coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
# }
# if(predict_eco == "juvenile abundance, hydro and spawners"){
#   coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
#   coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
#   coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)"
# }
if(predict_eco == "juveniles per spawner"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Smaller wet season baseflows (as eggs and hatchlings)"
  if("s1_SP_Tim" %in% coefs_interp){coefs_interp$s1_SP_Tim = "Later spring recession onset (as outmigrating smolt)"}
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  # coefs_interp$w1_Wet_BFL_Dur = "Longer wet season duration (as eggs and hatchlings)"
}
coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      yvlt$y_val_title[yvlt$y_val==y_val_chinook],
                      " based on hydrology only, including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```




## LASSO results: juvenile abundance on hydrologic metrics only

For purposes of statistical model comparison, we predicted juvenile abundance of coho and Chinook based on a predictor set that included only Z-scored hydrologic metrics.

```{r alt_lasso_analysis_2, echo = FALSE, warning = F}

# calculate lasso regression model and cross-validation objects
# (lasso: alpha = 1; ridge: alpha = 0)\
predict_eco = "juvenile abundance, hydro only"
y_val_coho = "coho_smolt_abun_est"
y_val_chinook = "chinook_juvenile_abundance"

# if(predict_eco == "juveniles per spawner"){
#   mod_obj_co = kfold_cv(mt = metrics_tab_screened, 
#                         y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv(mt = metrics_tab_screened_chinook, alpha =1, 
#                         y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
#   
#   alt_lambda_co = .135
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
#   
# } else if(predict_eco == "juvenile abundance, hydro and spawners"){
#   mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened, 
#                                    y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha =1, 
#                                    y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
#   # extract coefficients from the model using the optimal lambda value found in cross-validation
#   alt_lambda_co = .135
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             # , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
# }
if(predict_eco == "juvenile abundance, hydro only"){
  mts_jho = metrics_tab_screened
  mts_jho[,c("coho_spawners_zscored", "chinook_spawners_zscored")] = NULL
  mts_jho_ch = metrics_tab_screened_chinook
  mts_jho_ch [,c("coho_spawners_zscored","chinook_spawners_zscored")] = NULL
    
  mod_obj_co = kfold_cv(mt = mts_jho, 
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv(mt = mts_jho_ch, alpha =1, 
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .145
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
  
}





```


```{r juvAbunHydOnlyLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:juvAbunHydOnlyLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

# if(predict_eco %in% c("juvenile abundance, hydro and spawners")){
#   lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch)
# } 
if(predict_eco %in% c("juveniles per spawner",
                      "juvenile abundance, hydro only")){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch,
                alt_lambda_co = alt_lambda_co)
}

if(save_imgs == TRUE){
  dev.off()
  
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r juvAbunHydOnlyCoefTableCoho, echo = F, warning =F, message = F, results = 'asis'}

# Retrieve coefficients from lasso model

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names

# if(predict_eco == "juvenile abundance, hydro and spawners"){
#   coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
#   coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
#   coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
# } 
if(predict_eco == "juvenile abundance, hydro only"){
  coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
  coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
  # coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
  # coefs_interp$w2_Wet_BFL_Mag_50 = "Higher wet season baseflow (as juvenile fish)"
  coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)"
} 
# if(predict_eco == "juveniles per spawner"){
#   coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
#   coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"
#   coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)"
# }

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
                      yvlt$y_val_title[yvlt$y_val==y_val_coho]," based on hydrology only, including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.8)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r juvAbunHydOnlyCoefTableChinook, echo = F, warning =F, message = F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
if(predict_eco == "juvenile abundance, hydro only"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
}
if(predict_eco == "juvenile abundance, hydro and spawners"){
  coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)"
}
if(predict_eco == "juveniles per spawner"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Smaller wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season duration (as eggs and hatchlings)"
}
coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      yvlt$y_val_title[yvlt$y_val==y_val_chinook],
                      " based on hydrology only, including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 1.8)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```






## LASSO results: juvenile abundance on hydrologic metrics and spawner abundance

For purposes of statistical model comparison, we predicted juvenile abundance of coho and Chinook based on a predictor set that included Z-scored hydrologic metrics as well as Z-scored spawner abundances.


```{r alt_lasso_analysis, echo = FALSE, warning = F}

# calculate lasso regression model and cross-validation objects
predict_eco = "juvenile abundance, hydro and spawners"
y_val_coho = "coho_smolt_abun_est"; y_val_chinook = "chinook_juvenile_abundance"

# if(predict_eco == "juveniles per spawner"){
#   mts_noZ = metrics_tab_screened[,c("chinook_spawners_zscored", 
#                                     "coho_spawners_zscored")]
#   mts_noZ_ch = metrics_tab_screened_chinook[,c("chinook_spawners_zscored", 
#                                     "coho_spawners_zscored")]
#   mod_obj_co = kfold_cv(mt = metrics_tab_screened,
#                         y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv(mt = metrics_tab_screened_chinook, alpha =1,
#                         y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
# 
#   alt_lambda_co = .145
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
# 
# }
if(predict_eco == "juvenile abundance, hydro and spawners"){
  mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened,
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha =1,
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .135
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            # , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)

}





```


```{r juvAbunLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics and spawner abundance.\\label{fig:juvAbunLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

if(predict_eco == "juvenile abundance, hydro and spawners"){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch)
}
# if(predict_eco == "juveniles per spawner"){
#   lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch,
#                 alt_lambda_co = alt_lambda_co)
# }

if(save_imgs == TRUE){
  dev.off()
  }
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r juvAbunCoefTableCoho, echo = F, warning =F, message = F, results = 'asis'}

# Retrieve coefficients from lasso model
# predict_eco 

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names

if(predict_eco == "juvenile abundance, hydro and spawners"){
  # coefs_interp$coho_spawner_abundance = "Number of spawners (cohort's parents)"
  # coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
  # coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)"
  # coefs_interp$w2_Wet_BFL_Mag_50 = "Higher wet season baseflows (as overwintering juveniles)"
  coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
  coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
  coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
}
# if(predict_eco == "juveniles per spawner"){
#   coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
#   coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"
#   # coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)"
# }

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
                      yvlt$y_val_title[yvlt$y_val==y_val_coho],
                      " based on hydrologic metrics and spawner abundance, including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.8)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r juvAbunCoefTableChinook, echo = F, warning =F, message = F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
if(predict_eco == "juvenile abundance, hydro and spawners"){
  coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_Tim = "Earlier wet season onset (as eggs and hatchlings)"
}

coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      yvlt$y_val_title[yvlt$y_val==y_val_chinook],
                      " based on hydrologic metrics and spawner abundance, including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```



# MARSS Models


## MARSS models of juveniles per spawner, single hydrologic covariate

For purposes of statistical model comparison, we calculated multiple MARSS models (15 for coho and 8 for Chinook) that predicted the observed ratio of juveniles-per-spawner for coho and Chinook based on a single Z-scored hydrologic metric.

```{r MARSS1RegYVal, echo = F}
predict_eco = "juveniles per spawner"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
# if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# # Number of spawners included as predictor
# if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```



```{r MARSS_models_single_covar, echo = F}


# Specify MARSS model ------------------------------------------------------------------


## The code in the functions called below follows the R script
## Baruch_2023_Putah_Creek_MARSS.R, published in support of:
## Baruch et al., 2024. "Mimicking Functional Elements of the Natural Flow Regime
## Promotes Native Fish Recovery in a Regulated River." https://doi.org/10.1002/eap.3013.

model_list_file = "single cov MARSS models.rds"
coef_tab_file = "single cov marss coefs.csv"
aicc_tab_file = "single cov MARSS AICc tab.csv"

# extract season abbreviations from predictors
preds_season_list = strsplit(x = preds_screened, split = "_")
preds_season = unlist(lapply(X = preds_season_list, function(x){x[1]}))

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  coef_tab = read.csv(file.path(data_dir, coef_tab_file))
  
} else {
  # initialize results storage: AICc and coefficient tables and list of models
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  coef_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(coef_tab)=yvlt$y_val; rownames(coef_tab)=preds_screened
  
  list_of_mods = list()
  
  is = which(yvlt$y_val %in% c(y_val_coho, y_val_chinook))
  for(i in is){ #for coho and chinook juv abundance
    y_val_i = yvlt$y_val[i]
    # only run models for seasons that effect the selected ecological (y) value
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    # for each predictor in metrics_screened tab,
    for(j in 1:length(preds_for_y)){ 
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){ # there can be no missing covariate values
        # pull y-value table from metrics_tab
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        # fit a MARSS model (with the predictor as a single covariate) 
        marss_mod = get_single_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                       pred = pred_j)
        # add to list of models
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        # print(paste(y_val_i, "on", pred_j)) # track progress
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        coef_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        
      }
      
    }
  }
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))
  
  aicc_tab$pred = row.names(aicc_tab)
  coef_tab$pred = row.names(coef_tab)
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(coef_tab, file.path(data_dir, coef_tab_file), row.names = F)
}

```

```{r MARSSSingleCovarTableCoho, echo = F, warning =F, message = F, results = 'asis'}

aicc_order_co = order(aicc_tab[,y_val_coho])
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[aicc_order_co, "pred"])
results_y_co$coef = round(coef_tab[aicc_order_co, y_val_coho], 3)
results_y_co$aicc = round(aicc_tab[aicc_order_co, y_val_coho], 2)
colnames(results_y_co) = c("Covariate", "Coefficient", "AICc")
# make table for display
results_y_co_ft = results_y_co
didnt_model = is.na(results_y_co_ft$AICc)
results_y_co_ft$AICc[didnt_model] = "--"; results_y_co_ft$Coefficient[didnt_model] = "--"

caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")

coco_tab_ft = flextable(data=results_y_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 2)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 1)
coco_tab_ft


```


```{r MARSSSingleCovarTableChinook, echo = F, results = 'asis'}

aicc_order_ch = order(aicc_tab[,y_val_chinook])
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[aicc_order_ch, "pred"])
results_y_ch$coef = round(coef_tab[aicc_order_ch, y_val_chinook], 3)
results_y_ch$aicc = round(aicc_tab[aicc_order_ch, y_val_chinook], 2)
colnames(results_y_ch) = c("Covariate", "Coefficient", "AICc")
season_abbrev = substr(x = results_y_ch$Covariate, start = 1, stop = 2)
# make table for display
results_y_ch_ft = results_y_ch[!(season_abbrev %in% c("d2", "f2", "w2", "s2")),] # exclude predictors that don't temporally affect chinook smolt
didnt_model = is.na(results_y_ch_ft$AICc)
results_y_ch_ft$AICc[didnt_model] = "--"; results_y_ch_ft$Coefficient[didnt_model] = "--"


caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")


coch_tab_ft = flextable(data=results_y_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 1)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft



```

```{r MARSSSingleCovars, echo = F, warning = F, fig.height = 8, fig.cap = "Results of the three best single-hydrologic-covariate MARSS models to predict log-transformed Chinook and coho juvenile-per-spawners ratios with Z-scored hydrologic metrics.\\label{fig:MARSSSingleCovars}"}

n_mods = 3# for plot
top_cov_co = results_y_co$Covariate[order(results_y_co$AICc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_coho]))
pred_yrs_i_co = min(yrs_with_data):max(yrs_with_data)

top_cov_ch = results_y_ch$Covariate[order(results_y_ch$AICc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_chinook]))
pred_yrs_i_ch = min(yrs_with_data):max(yrs_with_data)


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_co,
                                   y_val = y_val_coho, top_cov = top_cov_co,
                                   top_models = top_mods_co)
  
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_ch,
                                   y_val = y_val_chinook, top_cov = top_cov_ch,
                                   top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```


## MARSS models of juveniles abundance, single hydrologic covariate

For purposes of statistical model comparison, we calculated multiple MARSS models (15 for coho and 8 for Chinook) that predicted juvenile abundance for coho and Chinook based on a single Z-scored hydrologic metric.

```{r MARSS2RegYVal, echo = F}
predict_eco = "juvenile abundance, hydro only"
# Hydro-only predictors
# if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
# if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```



```{r MARSS_juv_abun_models_single_covar, echo = F}


# Specify MARSS model ------------------------------------------------------------------


## The code in the functions called below follows the R script
## Baruch_2023_Putah_Creek_MARSS.R, published in support of:
## Baruch et al., 2024. "Mimicking Functional Elements of the Natural Flow Regime
## Promotes Native Fish Recovery in a Regulated River." https://doi.org/10.1002/eap.3013.

model_list_file = "juv abun single cov MARSS models.rds"
coef_tab_file = "juv abun single cov marss coefs.csv"
aicc_tab_file = "juv abun single cov MARSS AICc tab.csv"

# extract season abbreviations from predictors
preds_season_list = strsplit(x = preds_screened, split = "_")
preds_season = unlist(lapply(X = preds_season_list, function(x){x[1]}))

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  coef_tab = read.csv(file.path(data_dir, coef_tab_file))
  
} else {
  # initialize results storage: AICc and coefficient tables and list of models
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  coef_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(coef_tab)=yvlt$y_val; rownames(coef_tab)=preds_screened
  
  list_of_mods = list()
  
  is = which(yvlt$y_val %in% c(y_val_coho, y_val_chinook))
  for(i in is){ #for coho and chinook juv abundance
    y_val_i = yvlt$y_val[i]
    # only run models for seasons that effect the selected ecological (y) value
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    # for each predictor in metrics_screened tab,
    for(j in 1:length(preds_for_y)){ 
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){ # there can be no missing covariate values
        # pull y-value table from metrics_tab
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        # fit a MARSS model (with the predictor as a single covariate) 
        marss_mod = get_single_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                       pred = pred_j)
        # add to list of models
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        # print(paste(y_val_i, "on", pred_j)) # track progress
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        coef_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        
      }
      
    }
  }
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))
  
  aicc_tab$pred = row.names(aicc_tab)
  coef_tab$pred = row.names(coef_tab)
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(coef_tab, file.path(data_dir, coef_tab_file), row.names = F)
}

```

```{r MARSSJuvAbunSingleCovarTableCoho, echo = F, warning =F, message = F, results = 'asis'}

aicc_order_co = order(aicc_tab[,y_val_coho])
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[aicc_order_co, "pred"])
results_y_co$coef = round(coef_tab[aicc_order_co, y_val_coho], 3)
results_y_co$aicc = round(aicc_tab[aicc_order_co, y_val_coho], 2)
colnames(results_y_co) = c("Covariate", "Coefficient", "AICc")
# make table for display
results_y_co_ft = results_y_co
didnt_model = is.na(results_y_co_ft$AICc)
results_y_co_ft$AICc[didnt_model] = "--"; results_y_co_ft$Coefficient[didnt_model] = "--"

caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")

coco_tab_ft = flextable(data=results_y_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 2)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 1)
coco_tab_ft


```


```{r MARSSJuvAbunSingleCovarTableChinook, echo = F, results = 'asis'}

aicc_order_ch = order(aicc_tab[,y_val_chinook])
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[aicc_order_ch, "pred"])
results_y_ch$coef = round(coef_tab[aicc_order_ch, y_val_chinook], 3)
results_y_ch$aicc = round(aicc_tab[aicc_order_ch, y_val_chinook], 2)
colnames(results_y_ch) = c("Covariate", "Coefficient", "AICc")
season_abbrev = substr(x = results_y_ch$Covariate, start = 1, stop = 2)
# make table for display
results_y_ch_ft = results_y_ch[!(season_abbrev %in% c("d2", "f2", "w2", "s2")),] # exclude predictors that don't temporally affect chinook smolt
didnt_model = is.na(results_y_ch_ft$AICc)
results_y_ch_ft$AICc[didnt_model] = "--"; results_y_ch_ft$Coefficient[didnt_model] = "--"


caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")


coch_tab_ft = flextable(data=results_y_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 1)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft



```

```{r MARSSJuvAbunSingleCovars, echo = F, warning = F, fig.height = 8, fig.cap = "Results of the three best single-hydrologic-covariate MARSS models to predict log-transformed Chinook and coho outcomes with Z-scored hydrologic metrics.\\label{fig:MARSSJuvAbunSingleCovars}"}

n_mods = 3# for plot
top_cov_co = results_y_co$Covariate[order(results_y_co$AICc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_coho]))
pred_yrs_i_co = min(yrs_with_data):max(yrs_with_data)

top_cov_ch = results_y_ch$Covariate[order(results_y_ch$AICc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_chinook]))
pred_yrs_i_ch = min(yrs_with_data):max(yrs_with_data)


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_co,
                                   y_val = y_val_coho, top_cov = top_cov_co,
                                   top_models = top_mods_co)
  
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_ch,
                                   y_val = y_val_chinook, top_cov = top_cov_ch,
                                   top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```


## MARSS models of juvenile abundance, two covariates (spawner abundance and one hydrologic)

For purposes of statistical model comparison, we calculated multiple MARSS models (15 for coho and 8 for Chinook) that predicted juvenile abundance for coho and Chinook based on a single Z-scored hydrologic metric and Z-scored parental spawner abundance; thus, coefficients were calculated for both the hydrology and spawner covariates.

```{r MARSS3RegYVal, echo = F}
predict_eco = "juvenile abundance, hydro and spawners"
# Hydro-only predictors
# if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
# if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```

```{r newMetricsTabForMARSS3, echo = F}

metrics_tab = calc_metrics_hydro_by_affected_brood_year(
  hydro_by_brood_year = brood_year_hydro_tab,
  thresholds = thresh_for_corr_fig) 

# Clean metrics tab:
# 1) factorize water year category
metrics_tab$wy1_WY_Cat = as.numeric(factor(metrics_tab$wy1_WY_Cat,
                                           levels = c("dry year", "mod year", "wet year")))
metrics_tab$wy2_WY_Cat = as.numeric(factor(metrics_tab$wy2_WY_Cat,
                                           levels = c("dry year", "mod year", "wet year")))


yvlt = y_val_label_tab()
non_preds = c("brood_year", "smolt_year", yvlt$y_val)


if(zscore_flow_metrics == T){
  zscore_these = !(colnames(metrics_tab) %in% non_preds)
  metrics_mean = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = mean, na.rm=T)
  metrics_sd = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = sd, na.rm=T)
  metrics_tab[,zscore_these] = apply(X = metrics_tab[,zscore_these],
                                     MARGIN = 2, FUN = zscore_column_na_rm)
  
  if(predict_eco == "juvenile abundance, hydro and spawners"){
    # add spawners as a z-scored predictor variable
    metrics_tab$coho_spawners_zscored =
      zscore_column_na_rm(x = metrics_tab$coho_spawner_abundance)
    metrics_tab$chinook_spawners_zscored =
      zscore_column_na_rm(x = metrics_tab$chinook_spawner_abundance)
    non_preds = c(non_preds, "coho_spawners_zscored", "chinook_spawners_zscored")
    
  }
}

# transform data
if(log_transform_eco_metrics == T){
  metrics_tab[,yvlt$y_val] = log10(metrics_tab[,yvlt$y_val])
}



```



```{r MARSS_models_flow_and_spawn_covar, echo = F}

model_list_file = "flow and spawn MARSS models.rds"
flow_tab_file = "flow and spawn marss coefs_flow.csv"
spawn_tab_file = "flow and spawn marss coefs_spawn.csv"
aicc_tab_file = "flow and spawn AICc tab.csv"

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  flow_tab = read.csv(file.path(data_dir, flow_tab_file))
  spawn_tab = read.csv(file.path(data_dir, spawn_tab_file))
  
} else {
  
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  flow_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  spawn_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(flow_tab)=yvlt$y_val; rownames(flow_tab)=preds_screened
  colnames(spawn_tab)=yvlt$y_val; rownames(spawn_tab)=preds_screened
  
  
  smolts = c("coho_smolt_abun_est", "chinook_juvenile_abundance")
  spawns =  c("coho_spawners_zscored", "chinook_spawners_zscored")
  for(i in 1:2){
    y_val_i = smolts[i]
    y_val_spawn = spawns[i]
    # y_val_i = yvlt$y_val[smolts_i]
    # x_val_spawn = yvlt$y_val[spawn_i]
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[yvlt$y_val==y_val_i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    for(j in 1:length(preds_for_y)){
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        marss_mod = get_flow_and_spawn_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                               y_spawn_colname = y_val_spawn,
                                                               pred = pred_j)
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        flow_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        spawn_tab[row_finder, y_val_i] = marss_mod$coef["C.Spawners"]
        
      }
      # print(paste(y_val_i, "on", pred_j))
      # par(mfrow = c(4,2))
      # plot(marss_mod)
      
      # print(paste(y_val_i, "on", pred_j)) # track progress
      
    }
  }
  
  aicc_tab$pred = row.names(aicc_tab)
  flow_tab$pred = row.names(flow_tab)  
  spawn_tab$pred = row.names(spawn_tab)
  
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(flow_tab, file.path(data_dir, flow_tab_file), row.names = F)
  write.csv(spawn_tab, file.path(data_dir, spawn_tab_file), row.names = F)
}


```


```{r MARSSFlowAndSpawnCovarTableCoho, echo = F, results='asis'}



y_val = "coho_smolt_abun_est"
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
results_y_co$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
results_y_co$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_co$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_co$HtoSratio = round(results_y_co$flow / results_y_co$spawn,1)


afs_co_tab_ft = flextable(data=results_y_co)
caption_text = paste0("Characteristics of MARSS models of ", yvlt$y_val_title[yvlt$y_val==y_val], " using one hydrologic metric and Z-scored spawner abundance as the two covariates in each model.")


afs_co_tab_ft = set_caption(afs_co_tab_ft, caption = caption_text)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=1,  width = 2.5)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=3,  width = 1)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=4,  width = 1)
afs_co_tab_ft = flextable::set_header_labels(afs_co_tab_ft,
                                             values = list(
                                               pred = "Hydrologic Covariate",
                                               aicc = "AICc",
                                               flow ="Hydro Coef.",
                                               spawn = "Spawner Coef.",
                                               HtoSratio = "Hyd. / Sp."))
afs_co_tab_ft
```


```{r MARSSFlowAndSpawnCovarTableChinook, echo = F, results='asis'}
y_val = "chinook_juvenile_abundance"
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
results_y_ch$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
results_y_ch$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_ch$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 4)
results_y_ch$HtoS_ratio = round(results_y_ch$flow / results_y_ch$spawn,1)


afs_ch_tab_ft = flextable(data=results_y_ch)
caption_text = paste0("Characteristics of MARSS models of ", yvlt$y_val_title[yvlt$y_val==y_val], " using one hydrologic metric and Z-scored spawner abundance as the two covariates in each model.")
afs_ch_tab_ft = set_caption(afs_ch_tab_ft, caption = caption_text)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=1,  width = 2.5)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=3,  width = 1)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=4,  width = 1)
afs_ch_tab_ft = flextable::set_header_labels(afs_ch_tab_ft,
                                             values = list(
                                               pred = "Hydrologic Covariate",
                                               aicc = "AICc",
                                               flow ="Hydro Coef.",
                                               spawn = "Spawner Coef.",
                                               HtoSratio = "Hyd. / Sp."))

afs_ch_tab_ft
```

```{r MARSSHydroPlusSpawn, echo = F, warning = F, fig.height = 8, fig.cap = "Results of MARSS to predict log-transformed juvenile abundance for coho and Chinook outcomes with Z-scored hydrologic metrics plus spawner data.\\label{fig:MARSSHydroPlusSpawn}"}

n_mods = 3# for plot
top_cov_co = results_y_co$pred[order(results_y_co$aicc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data_yval = which(!is.na(metrics_tab[,y_val_coho]))
yrs_with_data_spawn = which(!is.na(metrics_tab[,"coho_spawners_zscored"]))
# pred_yrs_i_co = min(yrs_with_data_spawn):max(yrs_with_data_yval)
pred_yrs_i_co = min(yrs_with_data_spawn):max(yrs_with_data_spawn)#max(yrs_with_data_yval)

top_cov_ch = results_y_ch$pred[order(results_y_ch$aicc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data_yval = which(!is.na(metrics_tab[,y_val_chinook]))
yrs_with_data_spawn = which(!is.na(metrics_tab[,"chinook_spawners_zscored"]))
# pred_yrs_i_ch = min(yrs_with_data_spawn):max(yrs_with_data_yval)
pred_yrs_i_ch = min(yrs_with_data_spawn):max(yrs_with_data_spawn)#max(yrs_with_data_yval)


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_flow_and_spawn(metrics_tab = metrics_tab,
                                    pred_yrs_i = pred_yrs_i_co,
                                    y_val = y_val_coho, 
                                    top_cov = top_cov_co,
                                    top_models = top_mods_co)
  
  marss_predict_plot_flow_and_spawn(metrics_tab = metrics_tab,
                                    pred_yrs_i = pred_yrs_i_ch,
                                    y_val = y_val_chinook, 
                                    top_cov = top_cov_ch,
                                    top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```


<!-- # LASSO and MARSS coefficient comparison summary -->



---
title: Supplement to "A watershed-specific formula to predict salmon reproduction using functional flow metrics"
author: "Claire Kouba, Jason Wiener, Leland Scantlebury and Thomas Harter"
date: "Feb. 2025"
output: 
  bookdown::word_document2: 
    fig_caption: true
    number_sections: true
    global_numbering: true
bibliography: draft_library.bib
---

```{r supp_setup_dirs_load_data, include = FALSE}


knitr::opts_chunk$set(echo = TRUE)

# dev_mode = run by itself; dev_mode = F if you are calling it from the main .Rmd
dev_mode = T

if(dev_mode){
  # libraries
  library(lubridate)
  library(httr)
  library(ggplot2) # for barplots 
  library(gridExtra)
  library(corrplot)  # for data exploration/correlation plots
  library(dataRetrieval) # for usgs data
  library(data.table) #month function
  library(zoo) # rolling means
  library(sf)
  library(terra)
  library(tmap)
  library(grid) # for inset maps
  library(cowplot) # for inset maps
  library(ggthemes) # for colorblind palette
  library(flextable)
  library(glmnet) # lasso regression
  library(MARSS)
  library(here)
  
  # Directories
  ms_dir = here::here()
  scratch_dir = file.path(ms_dir, "scratch_work")
  data_dir = file.path(ms_dir, "Data")
  graphics_dir = file.path(ms_dir, "Graphics and Supplements")
  
  # Load spatial and tabular data
  
  # If the data files don't exist locally,
  # pull data from internet and local files
  if(!file.exists(file.path(ms_dir,"manuscript_data.RData"))){
    source(file.path(ms_dir,"01_DataRetrieval_Cleaning_SaveLocal.R")) 
  }
  
  load(file.path(ms_dir, "manuscript_data.RData")) # Load data layers/tables
  source(file.path(ms_dir,"02_Figure_Functions.R"))   # Load figure and table functions
  
  # Save figures as images, yes or no?
  save_figs_here = graphics_dir
  save_imgs=T # generate the figures in the folder
  include_figs = T
  replace_setting_fig = F # setting to F can save time if no need to re-render map
  fig_i = 1
  
  # pick last water year for the HB function to calculate a value for
  last_wy = 2023
}

```

```{r lassoRegYVal, echo = F}
predict_eco = "juvenile abundance, hydro and spawners"# "juveniles per spawner"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```

```{r supp_load_FF_metrics, include = FALSE}

if(dev_mode){
  log_transform_eco_metrics = T
  zscore_flow_metrics = T
  fflows = read_fflows_FJ(calculator = "Flashy")
  # fflows = read_fflows_FJ(calculator = "Regular")
  
  # produce metrics_tab
  
  brood_year_hydro_tab = tabulate_hydro_by_affected_brood_year(brood_years = 1999:2022,
                                                               smolt_years = 2001:2024)
  thresh_for_corr_fig = c(20,40,120)
  
  metrics_tab = calc_metrics_hydro_by_affected_brood_year(
    hydro_by_brood_year = brood_year_hydro_tab,
    thresholds = thresh_for_corr_fig) 
  
  # Clean metrics tab:
  # 1) factorize water year category
  metrics_tab$wy1_WY_Cat = as.numeric(factor(metrics_tab$wy1_WY_Cat,
                                             levels = c("dry year", "mod year", "wet year")))
  metrics_tab$wy2_WY_Cat = as.numeric(factor(metrics_tab$wy2_WY_Cat,
                                             levels = c("dry year", "mod year", "wet year")))
  
  
  yvlt = y_val_label_tab()
  non_preds = c("brood_year", "smolt_year", yvlt$y_val)
  
  
  if(zscore_flow_metrics == T){
    zscore_these = !(colnames(metrics_tab) %in% non_preds)
    metrics_mean = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = mean, na.rm=T)
    metrics_sd = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = sd, na.rm=T)
    metrics_tab[,zscore_these] = apply(X = metrics_tab[,zscore_these],
                                       MARGIN = 2, FUN = zscore_column_na_rm)
    
    if(predict_eco == "juvenile abundance, hydro and spawners"){
      # add spawners as a z-scored predictor variable
      metrics_tab$coho_spawners_zscored =
        zscore_column_na_rm(x = metrics_tab$coho_spawner_abundance)
      metrics_tab$chinook_spawners_zscored =
        zscore_column_na_rm(x = metrics_tab$chinook_spawner_abundance)
      non_preds = c(non_preds, "coho_spawners_zscored", "chinook_spawners_zscored")
      
    }
  }
  
  # transform data
  if(log_transform_eco_metrics == T){
    metrics_tab[,yvlt$y_val] = log10(metrics_tab[,yvlt$y_val])
  }
  
  
  # identify which columns we should keep in our correlation analysis
  corr_tab_all_metrics = cor(metrics_tab, use = "pairwise.complete.obs",
                             method = "spearman")
  ctl = collinear_screening_exercise(metrics_tab = metrics_tab,
                                     corr_tab_all_metrics = corr_tab_all_metrics,
                                     return_tab = "corr_tab_long_screened")
  
  keepers_co = c(non_preds, as.character(unique(ctl$Var1)))
  metrics_tab_screened = metrics_tab[,keepers_co]
  
  # Addl screening for temporal relevance to Chinook freshwater period
  metrics_before_chinook_outmigrate = 
    colnames(metrics_tab_screened) %in% non_preds |
    grepl(pattern = "d1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "f1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "w1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "s1", x = colnames(metrics_tab_screened)) | 
    grepl(pattern = "wy1", x = colnames(metrics_tab_screened)) 
  keepers_ch = intersect(x = keepers_co, colnames(metrics_tab_screened)[metrics_before_chinook_outmigrate])
  
  metrics_tab_screened_chinook = metrics_tab_screened[,keepers_ch]
  
  # if(predict_eco == "juvenile abundance, hydro and spawners"){
    screened_cols = c(keepers_co, "coho_spawners_zscored","chinook_spawners_zscored")
    screened_cols_ch = c(keepers_ch, "coho_spawners_zscored","chinook_spawners_zscored")
  # }
  
  preds_screened = screened_cols[!(screened_cols %in% non_preds)]
  # metrics_tab_screened = metrics_tab[,screened_cols]
  # metrics_tab_screened_chinook = metrics_tab[,screened_cols_ch]
  
  
}
```


# Supplement to "A watershed-specific formula to predict salmon reproduction using functional flow metrics" {-}

# History of flow-ecology relationships

A river's flow regime is often referred to as a "master variable" controlling geomorphic, chemical, and other conditions in its aquatic ecosystems, and organisms that have evolved to persist in specific flow regimes are commonly negatively affected by flow alteration [@BunnArthingtonBasic2002; @PoffEtAlEcological2010]. Consequently, in recent decades a diverse body of research has sought to identify and quantify ecological responses to changes in flow. 

Work on this topic spans multiple categories of ecological response, hydrologic predictor, and ultimate cause of hydrologic alteration. Two widely studied ecological response metric categories are, firstly, the stream health index, based on density and species richness of macroinvertebrates observed at designated sampling sites [e.g., @MonkEtAlFlow2006; @GuareschiEtAlHow2014; @KevicEtAlEffects2018; @MazorEtAlTools2018; @LarsenEtAlCombining2021; @PeekEtAlIdentifying2022], and secondly, fish diversity and community assemblage [e.g., @McManamayEtAlApplication2013; @PetersonFreemanIntegrating2016; @CartwrightEtAlPutting2017; @SinnathambyEtAlEcohydrological2018; @HainEtAlUsing2018; @GuedesEtAlArtificial2020; @YaoEtAlIdentifying2021]. Ecological responses can also be based on the abundance of a single or a few species, often of fish [@Stewart-KosterEtAlFish2011; @BoothEtAlDetermining2014; @DeWeberPetersonComparing2020; @HaleEtAlMy2023], as well as the extent of habitat types [@ChowdhuryDriverEcohydrological2007; @ArrianaBrandEtAlProjecting2011] and the presence of organisms including vegetation and plankton [@RiisEtAlVegetation2008; @CatfordEtAlSpecies2014; @QianEtAlEffects2016; @TesfayeEtAlClimatic2017; @SabyEtAlSensitivity2022]. Hydrologic predictors range widely **insert IHA and ELOHA**, with a heavy emphasis on extreme (low or high) flow events and the duration of components of the flow regime [e.g., @AyllonEtAlSpatiotemporal2014; @LamourouxOlivierTesting2015; @McManamayFrimpongHydrologic2015; @BowerEtAlQuantifying2022]. Causes of the change in hydrology include the operation of dams, changes in human water use, climate change, and natural flow variability [e.g., @AlomiaHerreraCarreraBurneoEnvironmental2017; @GaoEtAlHydrological2020; @WhiteEtAlMacroinvertebrate2018; @DaneshvarEtAlResponse2017; @HerbstEtAlDrought2019].

Investigations of flow-ecology relationships can also be grouped by approach [as in @TharmeGlobal2003 and @BrummerEtAlQuantitative2016]. In experimental flow studies the flow is directly manipulated with dam releases and biological responses are monitored [e.g., @KonradEtAlLargescale2011]. In longitudinal studies, long-term ecological and hydrological records can be used to infer local or regional correlations [e.g., @Mellado-DiazEtAlExploring2019]. Finally, in space-for-time approaches, the hydrology of multiple river systems in a region is used to populate the distribution of different hydrologic behavior, and ecological monitoring is related to flow differences between streams [e.g., @MonkEtAlMacroinvertebrate2008; @RiisEtAlVegetation2008; @CatfordEtAlSpecies2014; @BowerEtAlQuantifying2022]. Space-for-time analyses require considerably fewer resources than experimental flows and longitudinal studies, and thus are more numerous [@BrummerEtAlQuantitative2016]. 

Bridging the gap between science and policy has been a persistent challenge in this field. In many cases a key research motivation is to support decision-making in a variety of contexts, including dam operation, river restoration, and regulations of water extraction and land use [@RichterEtAlCollaborative2006; @HanEtAlEcohydrological2015; @SinnathambyEtAlEcohydrological2018; @BradleyEtAlHydroecological2017; @BrummerEtAlQuantitative2016]. But historical approaches based on relationship-finding are several steps removed from the policy-making process [@WebbEtAlAdaptive2018]. For example, the Ecological Limits of Hydrologic Alteration (ELOHA) framework or similar approaches can generate flow-ecology relationships or flow standards for particular rivers, but cannot translate specific management decisions into hydrologic or ecological outcomes [@RichterEtAlCollaborative2006; @CartwrightEtAlPutting2017]. 

An ideal framework for supporting decision-making would involve two key steps, firstly connecting land and water management actions to flow changes, and secondly connecting flow changes to ecological responses [@PetersonFreemanIntegrating2016; @DeWeberPetersonComparing2020; @AceroTrianaEtAlAssessing2021]. Both steps can involve complex models and substantial uncertainty, often representing an interdisciplinary challenge. Threshold values for "sufficient" flows would be ideal for a management context [@RosenfeldDeveloping2017], but can be difficult to identify and in some cases may not exist [@LuedersMcManamaySpecies2023].  Additionally, identifying natural flow regimes may be less immediately relevant to water resource management than an approach which can quantify ecological responses to "designer" or functional flows (which can often be controlled or influenced by dam releases) [@ArthingtonEtAlTEMPORARY2014; @WebbEtAlAdaptive2018], with the caveat that the designer flows approach may risk overlooking ecological flow needs that are not currently monitored [@BowerEtAlQuantifying2022]. Finally, stakeholders in at least one study requested flow-ecology relationships based on empirical monitoring, rather than more easily-simulated proxies like flow changes or thermal exposure [@DeWeberPetersonComparing2020].

The present study is a longitudinal "bottom-up" analysis, using empirical data and a case study, to identify flows most critical to support two specific species, and thus address the second of the two key links identified above. We use empirical data to develop a predictive model of a biological response to measurable (and simulatable) changes in flow metrics. We refer to this model as a "hydrologic benefit function" (i.e., intending to quantify the ecological services provided by flow) for a single species. This provides the critical link to evaluate fish outcomes resulting from future alternative watershed management practices which affect the hydrology of a stream ecosystem. A forthcoming companion study will investigate the other link, simulating flow changes from watershed management actions using an appropriate hydrologic model, then use hydrologic benefit functions to summarize the ecologic outcomes of a portfolio of water and land use scenarios.

## Previous work and limitations of a hydrologic predictor approach

In many previous studies of flow-ecology relationships (especially related to fisheries), predictors used to model the ecological response are flow-derived metrics, because flow data is often continuous and more abundant than other data types. Such models rely on the assumption that flow, directly or as a proxy for other variables (e.g., habitat) is the limiting factor in ecological recruitment, and thus that changes in flow can be directly translated to a population response. However, this ignores ecological theory. Under many circumstances, complex internal population feedbacks (such as high juvenile fish density leading to some juvenile fish mortality) or community dynamics (food webs) will be the limiting factors on fish population size. Consequently, many authors have argued that models of fish population responses to hydrologic changes should explicitly include ecological population modeling in addition to physical factors such as flow or geomorphology [@RosenfeldAssessing2003; @AndersonEtAlInstream2006; @LancasterDownesLinking2010; @AcremanEtAlEnvironmental2014; @ShentonEtAlPutting2012]. Additionally, in at least one case, fish population differences were not successfully predicted with a model based only on flow metrics; other variables such as water temperature were necessary to capture population shifts [@McManamayEtAlApplication2013].

In spite of these known limitations, the HB function proposed here uses only hydrologic predictors. In part this is a pragmatic approach, as this work is intended to set the foundation for assessing flow conditions in speculative hydrologic models, which do not simulate non-hydrologic, ecologically-relevant factors such as water quality or internal population dynamics. Furthermore, previous work suggests that seasonal flow availability is a major limiting factor on the local coho salmon fishery, supporting the hydrologic predictor only approach in this case [SRWC and Siskiyou RCD -@ScottRiverWatershedCouncilLimiting2005; NMFS -@NationalMarineFisheriesServiceFinal2014]. 

<!-- Lastly, the proposed HB function avoids some of the disadvantages of the snapshot method of comparing the two states of natural and altered flows [@WheelerEtAlStates2018], because the hydro-ecological dataset is relatively long. This temporal structure, covering a wide range of water year types, makes it possible to test the hypothesis that a measurable relationship exists between hydrologic signal and ecologic response, even within an otherwise more complex relationship involving many non-hydrologic factors. -->


# Scott River watershed setting and water use

## Geography, climate and hydrology

The Scott River drains a 2,109 km^2^ (814 square mile) watershed known as Scott Valley, flowing generally from south to north and joining the Klamath River after flowing through a steep canyon (Figure \@ref(fig:ScottWatershedMap)). The Scott is a major tributary to the Klamath, which drains an area spanning sections of Northern California and Southern Oregon (Figure \@ref(fig:ScottWatershedMap), inset map). Scott Valley has a Mediterranean climate with distinctive seasons of cool, wet winters and warm, dry summers. This seasonality in water input creates highly seasonal flow in the Scott River and tributary streams, where the beginning of a water year coincides with low flow conditions that immediately precede the onset of winter precipitation (Figure \@ref(fig:fjFlowFigure)). 

In most dry-to-average water years, sections of the Scott River become seasonally dewatered [NCRWQCB -@NorthCoastRegionalWaterQualityControlBoardStaff2005; Figure 5 in @TolleyEtAlSensitivity2019]. This occurs when the elevation of the water table drops below the bottom of the river channel, as streams and groundwater are highly interconnected in the Scott River watershed. Tributary streams, particularly along their alluvial fan apeces, and the upper Scott River are sources of recharge to the aquifer [@MackGeology1958; @HarterHinesSCOTT2008]. Groundwater discharge sustains streamflow in low-lying areas, especially during the dry season of August through October or November [@TolleyEtAlSensitivity2019]. For consistency with regulatory and management programs in this region, this document uses units of cubic feet per second (cfs) when reporting hydrologic fluxes.


<!-- ```{r fig.id="faithfuld-plot", fig.cap.pre="Supplementary Figure",fig.autonum.start_at=1,fig.lp="supp-fig"} -->
<!-- knitr::include_graphics("images/MyImage.png")  -->

<!-- ``` -->
<!-- blah blah blah -->

<!-- ```{r fig.id="faithfuld-plot2", fig.cap.pre="Supplementary Figure",fig.lp="supp-fig"} -->
<!-- knitr::include_graphics("images/MyImage2.png") -->

<!-- ``` -->

<!-- fig.lp="S", fig.autonum.start_at = 1, -->
```{r fjFlowFigure, echo=FALSE, fig.cap.pre = "S", fig.cap="Each translucent line traces one annual hydrograph measured at the Fort Jones gauge, and the darker lines illustrate the 30-day smoothed median daily flow in Dry, Below Average, Above Average, and Wet water year types, for water years 1942-2023. The water year type is defined by quartiles of the distribution of total annual flow.", warning=F}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 6, units = "in", res = res_dpi)
  
  fj_flow_figure(roll_window = 30)
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```

## Water uses and management objectives

Water in Scott Valley is used for agricultural, domestic, and municipal supply. It also facilitates recreation and provides Native American cultural services, among other designated beneficial uses [NCRWQCB -@NorthCoastRegionalWaterQualityControlBoardACTION2006]. Because the watershed is undammed, managers and water users influence Scott River flow primarily via diversion of surface waters and pumping of groundwater. Consequently, the most powerful tool available to manage Scott River water flow is regulation of land use and thus water demand [Siskiyou County -@SiskiyouCountyScott2021]. 

Historically, local regulation of land use has focused on maintaining the rural and agricultural character of Scott Valley [@ScottValleyAreaPlanCommitteeScott1980]. Regulating land use to improve ecological outcomes would entail significant economic, political and social risks, because much of the economic activity in this area is related to agriculture. The primary crops grown in Scott Valley are pasture for cattle feed and alfalfa [Siskiyou County -@SiskiyouCountyScott2021]. In addition to local economic impact, Scott River conditions influence fish population dynamics both within the watershed and in the broader Klamath system. The health of the Klamath salmon run has implications for commercial fishing, recreational activities, and cultural practices of Native American tribes in the region, including the Quartz Valley Indian Community and the Karuk and Yurok Tribes [@MansfieldEtAlKlamath2012].

Recent management activity has included the leasing of surface water rights from landowners to enhance summer flows [e.g., SRWT -@Magranet20172018], the prioritization of stream reaches for habitat restoration [SRWC -@ScottRiverWatershedCouncilRestoring2018], several pilot projects to construct and assess the impact of beaver dam analogs (BDAs) on aquatic habitat and fish populations [Yokel -@YokelEtAlScott2018], a coordinated rescue effort to relocate juvenile salmon that were cut off from outmigrating by disconnected river reaches [CDFW -@CaliforniaDepartmentofFishandWildlifeEtAlCooperative2015], and the development of long-term groundwater management plan by Siskiyou County and local stakeholders [Siskiyou County -@SiskiyouCountyScott2021].

# Species of concern - coho and Chinook salmon

### Life cycle and status of coho salmon (*Oncorhynchus kisutch*)

Returning adult coho spawn in natal streams between November and January [@KnechtleGiudice20192020], and juvenile coho spend approximately one full year in freshwater streams before migrating to the ocean as smolts [@MoyleCoho2002; @McMahonHabitat1983]. In the Scott River system these natal streams are the tributaries along the margins of the valley floor [SRCD -@SiskiyouResourceConservationDistrictFinal2004].

In previous studies, the strongest predictor of juvenile coho abundance in a stream system was spatial habitat [@BradfordEtAlEmpirical1997; @NickelsonEtAlSeasonal1992; @BustardNarverAspects1975], although adequate food and cover were also important [@McMahonHabitat1983]. The primary mechanism for spatial constraints on abundance appears to be that juvenile coho become more territorial as they grow [@McMahonHabitat1983].

Some coho salmon return to spawn at age 2 as grilse, but the majority (e.g., 92.4% in 2020) return after more than one year in the ocean, giving the Scott coho salmon run its characteristic 3-year cohort return interval [@KnechtleGiudice20192020].

Coho salmon in the Scott Valley are listed as threatened under the federal and California Endangered Species Acts (ESAs). They belong to the Southern Oregon / Northern California Coast (SONCC) Evolutionarily Significant Unit (ESU), which was listed as threatened under the federal and state ESAs in 1997 and 2005, respectively. State-wide, coho populations have declined more than 90% since the 1940s [@BrownEtAlHistorical1994]. 

### Life cycle and status of Chinook salmon (*Onchorhynchus tsawytscha*)

Chinook salmon in the Scott Valley are a candidate for listing under the federal ESA, and are not listed under the California ESA. They belong to the Southern Oregon / Northern California Coast (SONCC) Evolutionarily Significant Unit (ESU). 
Typically, adult Chinook salmon return to spawn in Scott Valley streams in the fall months September-December when flows are sufficient for salmon passage [@KnechtleGiudice20192020; @MagranetScott2015a; @MagranetScott2017]. Chinook in this watershed hatch in the spring and migrate to the ocean in their first year of life [@AgrawalEtAlPREDICTING2005]. Chinook spend the majority of their life in the ocean, and return to their natal streams shortly before spawning [@GrootMargolisLife1991]. However, substantial variability exists within this broader structure: Chinook salmon exhibit variation in multiple life stages, including time of seaward migration, age of maturity, and timing of return to natal stream [@GrootMargolisLife1991; @BourretEtAlDiversity2016].

As recently as 2013, the SONCC Chinook population was stable and becoming more complex [@WainwrightEtAlCCIEA2013]. However, in monitoring from 2015-2020, the number of returning adults (the escapement) was 65% below historical average, and the change in the Scott River Chinook population has been more rapid than the decline in the overall Klamath Basin Chinook run [@CaliforniaDepartmentofFishandWildlifeScott2021]. Ocean conditions may have contributed to a broad decline in Chinook populations from Alaska to California [@WelchEtAlSynthesis2021]. Some studies have found that the leading cause of declining Chinook populations are ocean conditions, including including temperature, upwelling currents and food resources [@HuntEtAlOceanic1999], while others have identified hatchery practices as the primary cause [@QuinonesEtAlPotential2014]. 


# Hydrologic Metrics

## Functional Flows Background
```{r funcFlowTermsTab, echo = FALSE, results = 'asis'}

ff_tab = read.csv(file.path(data_dir,"Hydro Metrics Table_Functional Flows.csv"))

#Create caption and column labels
caption_text = "Explanation of functional flows used in this analysis (Patterson et al. 2020; Baruch et al. 2024). Each type of metric, for each threshold value (e.g., 100 cfs or 50th flow percentile), produces one value per water year."
column_labels = c("Abbrev.","Full Name", "Thresholds","Description")
colnames(ff_tab) = column_labels

ff_tab_ft = flextable(data=ff_tab)
ff_tab_ft = set_caption(ff_tab_ft, caption = caption_text)
ff_tab_ft = flextable::width(ff_tab_ft,j=1,  width = 1.3)
ff_tab_ft = flextable::width(ff_tab_ft,j=2,  width = 1.5)
ff_tab_ft = flextable::width(ff_tab_ft,j=3, width = 1)
ff_tab_ft = flextable::width(ff_tab_ft,j=4,  width = 3.1)
ff_tab_ft

``` 

<!-- fig.id="faithfuld-plot2", fig.cap.pre="Supplementary Figure",fig.lp="supp-fig" -->

```{r fig2Yarnell2020,  echo = F, message = F, warning =F, fig.height = 8.5, fig.cap = "Figure 2 from Yarnell et al., 2020. Illustration of five functional flow categories identified for a mixed rain-snowmelt runoff river in California."}

if(save_imgs==T){
  file.copy(from = file.path(graphics_dir, "Graphics source", "Yarnell2020_Fig2.png"),
            to = file.path(save_figs_here, paste0("Figure S",fig_i,".png")))
}

if(include_figs==T){
  knitr::include_graphics(file.path(save_figs_here, paste0("Figure S",fig_i,".png")))
}


fig_i = fig_i +1

```


## Hydrologic Metrics Designed for This Study

```{r customHydroMetricsTab, echo = FALSE, results = 'asis'}

ff_tab = read.csv(file.path(data_dir,"Hydro Metrics Table_Custom metrics.csv"))

#Create caption and column labels
caption_text = "Explanation of custom hydrologic metrics designed for this study, which are less complex than functional flows in that they do not rely on signal processing techniques. Each type of metric, for each threshold value (e.g., 120 cfs), produces one value per water year. Metric names used in predictive modeling also include abbreviations for salmon life periods (Table 3 below); e.g., f1_recon_120, referring to the timing of flow exceeding 120 cfs in a ohort's first fall season."
column_labels = c("Abbrev.","Full Name", "Thresholds","Description")
colnames(ff_tab) = column_labels

ff_tab_ft = flextable(data=ff_tab)
ff_tab_ft = set_caption(ff_tab_ft, caption = caption_text)
ff_tab_ft = flextable::width(ff_tab_ft,j=1,  width = 1.1)
ff_tab_ft = flextable::width(ff_tab_ft,j=2,  width = 1.5)
ff_tab_ft = flextable::width(ff_tab_ft,j=3, width = 1)
ff_tab_ft = flextable::width(ff_tab_ft,j=4,  width = 3.2)
ff_tab_ft

```  


```{r reconnectExplainerHydrograph, echo = F, warning =F, fig.cap = "Reconnection and disconnection dates are highlighted for one water year. Two example thresholds, 20 and 120 cfs (0.57 and 3.4 cms, respectively) are highlighted, which correspond to distinct river connectivity (and salmon habitat access) conditions in the Scott River watershed as observed at the Fort Jones gauge (see Results for more detail on selection of flow thresholds)."}


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 4.5, units = "in", res = res_dpi)
  
  recon_and_discon_explainer_hydrograph(
    water_year = 2016, tot_flow_annotate = F, 
    connection_date_annotate = "20_and_120_only")
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```

## Screening Predictors for Collinearity

```{r predCorrScreeningTable, echo = F, warning =F, comment = F}

# Calculate correlation matrix
corr_tab_all_metrics = cor(metrics_tab, use = "pairwise.complete.obs",
                           method = "spearman")

elim_pred_tab = collinear_screening_exercise(metrics_tab = metrics_tab,
                                             corr_tab_all_metrics = corr_tab_all_metrics)

caption_text = "Groups of collinear predictors (absolute value of R greater than 0.7), interpretation of their hydrologic significance, and the predictor selected from each group to reduce collinearity."

column_labels = c("Group of Collinear Predictors","Hydrologic Significance (Coho Life Stage)",
                  "Predictor Selected from Group")
colnames(elim_pred_tab) = column_labels

ept_tab_ft = flextable(data=elim_pred_tab)
ept_tab_ft = set_caption(ept_tab_ft, caption = caption_text)
ept_tab_ft = flextable::width(ept_tab_ft,j=1,  width = 2.8)
ept_tab_ft = flextable::width(ept_tab_ft,j=2,  width = 2)
ept_tab_ft = flextable::width(ept_tab_ft,j=3,  width = 1.8)
ept_tab_ft
```

### Groups 1 and 2

These metrics describe the magnitude and timing of wet-season flows (years 1 and 2), effectively characterized by the question, 'how wet was the wet season?' We selected `w1_Wet_BFL_Mag_50` and `w2_Wet_BFL_Mag_50` as the most conceptually central metric to represent the amount of water passing through the watershed during two wet seasons: `w1`, the first wet season, experienced by a cohort as eggs and newly-hatched alevin and fry, and `w2`, experienced by the cohort as overwintering parr.

### Group 3

These metrics describe the magnitude and timing of dry-season flows before the cohort's spawning. We selected `d1_DS_Mag_50` as the most conceptually central metric to represent the amount of water passing through the watershed during the dry season before a cohort's parents' spawning.

### Groups 4 and 5

These metrics quantify the timing of the wet season onset and duration (year 2). We selected `w2_Wet_Tim`, the timing of the onset of the second wet season, and `w2_Wet_BFL_Dur`, the duration of wet season baseflow, to characterize the timing of the wet season experienced by a cohort of coho as overwintering juveniles.

### Groups 6 and 7

These metrics quantify the magnitude of the fall pulse flow (years 1 and 2). We selected the fall flow increase `FA_dif_num` [from @Baruch2024] for both years, as it is the only fall flows magnitude metric occurring in every water year, with no missing values.

# Ecological Data Features


## Sources and methods


```{r ecoMetricsMonitoringTab, echo = FALSE, results = 'asis'}

em_tab = read.csv(file.path(data_dir,"Ecological Monitoring Data Source Information.csv"))

#Create caption and column labels
caption_text = "Description and source information for ecological observations of the two salmonid species of concern."
column_labels = c("Obs. ID","Abbrev.","Description", "Monitoring Details", "Source(s)", "Predictor Seasons")
colnames(em_tab) = column_labels

em_tab_ft = flextable(data=em_tab)
em_tab_ft = set_caption(em_tab_ft, caption = caption_text)
em_tab_ft = flextable::width(em_tab_ft,j=1,  width = .5)
em_tab_ft = flextable::width(em_tab_ft,j=2,  width = 1.5)
em_tab_ft = flextable::width(em_tab_ft,j=3, width = 1.5)
em_tab_ft = flextable::width(em_tab_ft,j=4,  width = 1.5)
em_tab_ft = flextable::width(em_tab_ft,j=5,  width = 1.2)
em_tab_ft = flextable::width(em_tab_ft,j=6,  width = 0.7)
em_tab_ft

```  


## Autocorrelation in ecological records

Autocorrelation, with a lag of 3, is evident in two ecological records: the abundances of coho redds and coho smolt (Figure \@ref(fig:acfEcoRecords)). In other words, the 3-year-lagged record of coho smolt approaches, and for redds exceeds, the 95% confidence interval that it is not random noise. 

Interestingly, for coho spawner abundance, although the sign of the autocorrelation is positive at 3 and 6 year lags (which we would expect, reflecting the cohort structure), autocorrelation in the coho spawner record is weaker than in the redd and smolt records. 

No significant autocorrelation is evident in the three Chinook data types, and none is observed for coho smolt per female. 

```{r acfEcoRecords, echo = F, warning = F, fig.height = 8, fig.cap = "Autocorrelation function estimates for all available ecological outcome records.\\label{fig:acfEcoRecords}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

par(mfrow = c(3,3))
for(i in 1:nrow(yvlt)){
  y_i = yvlt$y_val[i]
  y_vals_continuous = get_longest_cont_ts(y = metrics_tab[,y_i], 
                                          y_years = metrics_tab$brood_year)
  acf(x = y_vals_continuous$y_cont,
      main = yvlt$y_val_label[i],
      sub = paste0("Continuous record length: ",nrow(y_vals_continuous), " years"))
  legend(x = "topright", bty = "n", legend = LETTERS[i])
}


if(save_imgs == TRUE){dev.off()}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1
```

# Six statistical modeling structures - method details

**LASSO model of juveniles-per-spawner:** Cross-validation produced a clear minimum-error $\lambda$ value for Chinook (Figure \@ref(fig:LASSOResultsCohoChinook)). For coho, we proposed an alternate lambda value that explained more percent deviance (Figure \@ref(fig:LASSOResultsCohoChinook), middle left panel) while retaining a near-minimum test error (Figure \@ref(fig:LASSOResultsCohoChinook), top left panel). This produced a model with three non-zero coefficients for both species (Figure \@ref(fig:LASSOResultsCohoChinook), lower two panels; Tables \@ref(tab:coefTableCoho) and \@ref(tab:coefTableChinook))

**LASSO model of juvenile abundance, hydrology and spawners:** the selected predictors included spawners only for Chinook (Tables \@ref(tab:juvAbunCoefTableCoho) and \@ref(tab:juvAbunCoefTableChinook)). 

**Lasso model of juvenile abundance, hydrologic metrics only:** replicating the approach for the LASSO model of juveniles-per-spawner, we proposed an alternate lambda value for the coho model (Figure \@ref(fig:juvAbunHydOnlyLassoCohoChinook)). Selected predictors for coho were similar to the juvenile abundance, hydrology-plus-spawners LASSO model, while for Chinook, the minimum-error model selected only one predictor (Tables \@ref(tab:juvAbunHydOnlyCoefTableCoho) and \@ref(tab:juvAbunHydOnlyCoefTableChinook)). 

**MARSS models of juveniles-per-spawner, single hydrologic covariate:** hydrology order of importance is taken from the small-sample-size-corrected Akaike Information Criterion (AICc), i.e., the lower the AICc, the better the prediction based on that hydrologic metric (Tables \@ref(tab:MARSSSingleCovarTableCoho) and \@ref(tab:MARSSSingleCovarTableChinook)).

**MARSS models of juveniles abundance, single hydrologic covariate:** hydrology order of importance interpreted as described above (Tables \@ref(tab:MARSSSingleCovarTableCoho) and \@ref(tab:MARSSSingleCovarTableChinook)); this is used to test the utility of adding spawners as a covariate.

**MARSS models of juvenile abundance, two covariates:** This model structure calculates a coefficient value for spawners and for any single hydrologic metric (Tables \@ref(tab:MARSSFlowAndSpawnCovarTableCoho) and \@ref(tab:MARSSFlowAndSpawnCovarTableChinook)). For the four best models, hydrology coefficients are equal to or greater than coefficients for spawners. For worse, higher-AICc models, spawner influence grows to be much greater than the hydrology.

MARSS models tended to perform better at predicting coho than Chinook (Figures \@ref(fig:MARSSSingleCovars),  \@ref(fig:MARSSJuvAbunSingleCovars), and \@ref(fig:MARSSHydroPlusSpawn), possibly because Chinook records did not contain significant autocorrelation (Figure \@ref(fig:acfEcoRecords)). 

# LASSO regression 

LASSO (Least Absolute Shrinkage and Selection Operator) regression minimizes the following quantity:

$$\sum_{i=1}^{n}{(y_i-\beta_0-\sum_{j=1}^{p}{\beta_jx_{ij}})^2}+\lambda\sum_{j=1}^{p}{|\beta_j|}$$

Where:

* $n$ is the number of ecological observations;
* $i$ enumerates the brood years;
* $p$ is the number of predictors;
* $j$ enumerates the hydrologic predictors;
* $x_{ij}$ is the observed value of hydrologic predictor $j$ for brood year $i$ (independent variable);
* $y_i$ is the observed value of ecological response in the salmon cohort with brood year $i$ (dependent variable);
* $\beta_0$ is the intercept value for the resulting linear model;
* $\beta_j$ is the coefficient value for hydrologic predictor $j$ in the resulting linear model; and
* $\lambda$ is a tuning parameter, referred to as a shrinkage penalty.

In this formulation, sufficiently large values of lambda generally shrink the values of all coefficients to 0 (the infinite-lambda case). The infinite-lambda case produces a model consisting solely of the $\beta_0$ intercept term, which takes on a value that is the average of all the observed $y$ values. Conversely, sufficiently small values of $\lambda$ will produce linear models incorporating information from many predictors. 
The selection of the appropriate $\lambda$ value is a critical step in the regression procedure, and is best done using cross-validation within the training dataset [@JamesEtAlIntroduction2013].

## LASSO results: juveniles-per-spawner based on hydrologic metrics

For purposes of statistical model comparison, we predicted the ratio of juveniles per spawner for coho and Chinook based on a predictor set that included only Z-scored hydrologic metrics.

```{r alt_lasso_analysis_1, echo = FALSE, warning = F}

# calculate lasso regression model and cross-validation objects
# (lasso: alpha = 1; ridge: alpha = 0)\
predict_eco = "juveniles per spawner"
y_val_coho = "coho_smolt_per_fem"; y_val_chinook = "chinook_juv_per_adult"

# if(predict_eco == "juvenile abundance, hydro and spawners"){
#   mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened, 
#                                    y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha =1, 
#                                    y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
#   # extract coefficients from the model using the optimal lambda value found in cross-validation
#   alt_lambda_co = .135
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             # , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
# }
if(predict_eco %in% c("juvenile abundance, hydro only", 
                      "juveniles per spawner")){
  mts_jho = metrics_tab_screened
  mts_jho[,c("coho_spawners_zscored", "chinook_spawners_zscored")] = NULL
  mts_jho_ch = metrics_tab_screened_chinook
  mts_jho_ch [,c("coho_spawners_zscored","chinook_spawners_zscored")] = NULL

  mod_obj_co = kfold_cv(mt = mts_jho,
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv(mt = mts_jho_ch, alpha =1,
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .135
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)

}





```


```{r jpsLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:juvAbunHydOnlyLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

# if(predict_eco %in% c("juvenile abundance, hydro and spawners")){
#   lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch)
# } 
if(predict_eco %in% c("juveniles per spawner",
                      "juvenile abundance, hydro only")){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch,
                alt_lambda_co = alt_lambda_co)
}

if(save_imgs == TRUE){
  dev.off()
  # pred_tab_filename = "Supplemental Table 3. Coho Salmon Lasso Coefficients.csv"
  # write.csv(x=coefs_co$coef_all, file=file.path(graphics_dir,pred_tab_filename),
  #           quote=F, row.names = F)
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r jpsCoefTableCoho, echo = F, warning =F, results = 'asis'}

# Retrieve coefficients from lasso model

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names

# if(predict_eco == "juvenile abundance, hydro and spawners"){
#   coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
#   coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
#   coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
# } 
# if(predict_eco == "juvenile abundance, hydro only"){
#   coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
#   coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
#   # coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
#   # coefs_interp$w2_Wet_BFL_Mag_50 = "Higher wet season baseflow (as juvenile fish)"
#   coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)"
# } 
if(predict_eco == "juveniles per spawner"){
  coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
  coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"
  coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)"
}

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
                      yvlt$y_val_title[yvlt$y_val==y_val_coho]," based on hydrology only, including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.5)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r jpsCoefTableChinook, echo = F, warning =F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
# if(predict_eco == "juvenile abundance, hydro only"){
#   coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
# }
# if(predict_eco == "juvenile abundance, hydro and spawners"){
#   coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
#   coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
#   coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)"
# }
if(predict_eco == "juveniles per spawner"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Smaller wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season duration (as eggs and hatchlings)"
}
coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      yvlt$y_val_title[yvlt$y_val==y_val_chinook],
                      " based on hydrology only, including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 1.5)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```




## LASSO results: juvenile abundance on hydrologic metrics only

For purposes of statistical model comparison, we predicted juvenile abundance of coho and Chinook based on a predictor set that included only Z-scored hydrologic metrics.

```{r alt_lasso_analysis_2, echo = FALSE, warning = F}

# calculate lasso regression model and cross-validation objects
# (lasso: alpha = 1; ridge: alpha = 0)\
predict_eco = "juvenile abundance, hydro only"
y_val_coho = "coho_smolt_abun_est"
y_val_chinook = "chinook_juvenile_abundance"

# if(predict_eco == "juveniles per spawner"){
#   mod_obj_co = kfold_cv(mt = metrics_tab_screened, 
#                         y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv(mt = metrics_tab_screened_chinook, alpha =1, 
#                         y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
#   
#   alt_lambda_co = .135
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
#   
# } else if(predict_eco == "juvenile abundance, hydro and spawners"){
#   mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened, 
#                                    y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha =1, 
#                                    y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
#   # extract coefficients from the model using the optimal lambda value found in cross-validation
#   alt_lambda_co = .135
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             # , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
# }
if(predict_eco == "juvenile abundance, hydro only"){
  mts_jho = metrics_tab_screened
  mts_jho[,c("coho_spawners_zscored", "chinook_spawners_zscored")] = NULL
  mts_jho_ch = metrics_tab_screened_chinook
  mts_jho_ch [,c("coho_spawners_zscored","chinook_spawners_zscored")] = NULL
    
  mod_obj_co = kfold_cv(mt = mts_jho, 
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv(mt = mts_jho_ch, alpha =1, 
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .145
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
  
}





```


```{r juvAbunHydOnlyLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:juvAbunHydOnlyLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

# if(predict_eco %in% c("juvenile abundance, hydro and spawners")){
#   lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch)
# } 
if(predict_eco %in% c("juveniles per spawner",
                      "juvenile abundance, hydro only")){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch,
                alt_lambda_co = alt_lambda_co)
}

if(save_imgs == TRUE){
  dev.off()
  # pred_tab_filename = "Supplemental Table 3. Coho Salmon Lasso Coefficients.csv"
  # write.csv(x=coefs_co$coef_all, file=file.path(graphics_dir,pred_tab_filename),
  #           quote=F, row.names = F)
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r juvAbunHydOnlyCoefTableCoho, echo = F, warning =F, results = 'asis'}

# Retrieve coefficients from lasso model

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names

# if(predict_eco == "juvenile abundance, hydro and spawners"){
#   coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
#   coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
#   coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
# } 
if(predict_eco == "juvenile abundance, hydro only"){
  coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
  coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
  # coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
  # coefs_interp$w2_Wet_BFL_Mag_50 = "Higher wet season baseflow (as juvenile fish)"
  coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)"
} 
# if(predict_eco == "juveniles per spawner"){
#   coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
#   coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"
#   coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)"
# }

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
                      yvlt$y_val_title[yvlt$y_val==y_val_coho]," based on hydrology only, including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.5)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r juvAbunHydOnlyCoefTableChinook, echo = F, warning =F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
if(predict_eco == "juvenile abundance, hydro only"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
}
if(predict_eco == "juvenile abundance, hydro and spawners"){
  coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)"
}
if(predict_eco == "juveniles per spawner"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Smaller wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season duration (as eggs and hatchlings)"
}
coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      yvlt$y_val_title[yvlt$y_val==y_val_chinook],
                      " based on hydrology only, including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 1.5)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```






## LASSO results: juvenile abundance on hydrologic metrics and spawner abundance

For purposes of statistical model comparison, we predicted juvenile abundance of coho and Chinook based on a predictor set that included Z-scored hydrologic metrics as well as Z-scored spawner abundances.


```{r alt_lasso_analysis, echo = FALSE, warning = F}

# calculate lasso regression model and cross-validation objects
predict_eco = "juvenile abundance, hydro and spawners"
y_val_coho = "coho_smolt_abun_est"; y_val_chinook = "chinook_juvenile_abundance"

# if(predict_eco == "juveniles per spawner"){
#   mts_noZ = metrics_tab_screened[,c("chinook_spawners_zscored", 
#                                     "coho_spawners_zscored")]
#   mts_noZ_ch = metrics_tab_screened_chinook[,c("chinook_spawners_zscored", 
#                                     "coho_spawners_zscored")]
#   mod_obj_co = kfold_cv(mt = metrics_tab_screened,
#                         y_val = y_val_coho, alpha = 1)
#   mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
#   mod_obj_ch = kfold_cv(mt = metrics_tab_screened_chinook, alpha =1,
#                         y_val = y_val_chinook)
#   mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
# 
#   alt_lambda_co = .145
#   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
#                             , alt_lambda = alt_lambda_co
#   )
#   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
# 
# }
if(predict_eco == "juvenile abundance, hydro and spawners"){
  mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened,
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha =1,
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .135
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            # , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)

}





```


```{r juvAbunLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:juvAbunLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

if(predict_eco == "juvenile abundance, hydro and spawners"){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch)
}
# if(predict_eco == "juveniles per spawner"){
#   lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch,
#                 alt_lambda_co = alt_lambda_co)
# }

if(save_imgs == TRUE){
  dev.off()
  # pred_tab_filename = "Supplemental Table 3. Coho Salmon Lasso Coefficients.csv"
  # write.csv(x=coefs_co$coef_all, file=file.path(graphics_dir,pred_tab_filename),
  #           quote=F, row.names = F)
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r juvAbunCoefTableCoho, echo = F, warning =F, results = 'asis'}

# Retrieve coefficients from lasso model

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names

if(predict_eco == "juvenile abundance, hydro and spawners"){
  # coefs_interp$coho_spawner_abundance = "Number of spawners (cohort's parents)"
  # coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
  coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
  coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
  # coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)"
  # coefs_interp$w2_Wet_BFL_Mag_50 = "Higher wet season baseflows (as overwintering juveniles)"
  coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
}
# if(predict_eco == "juveniles per spawner"){
#   coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
#   coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"
#   # coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)"
# }

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
                      y_val_coho,", including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.5)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r juvAbunCoefTableChinook, echo = F, warning =F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
if(predict_eco == "juvenile abundance, hydro and spawners"){
  coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)"
}
# if(predict_eco == "juveniles per spawner"){
#   coefs_interp$w1_Wet_BFL_Mag_50 = "Smaller wet season baseflows (as eggs and hatchlings)"
#   coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
#   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season duration (as eggs and hatchlings)"
# }
coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      y_val_chinook,", including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 1.5)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```



# MARSS Models

Multi-variate autoregressive state-space (MARSS) models are often used to model time series data (in which )



## MARSS models of juveniles per spawner, single hydrologic covariate

For purposes of statistical model comparison, we calculated multiple MARSS models (15 for coho and 8 for Chinook) that predicted the observed ratio of juveniles-per-spawner for coho and Chinook based on a single Z-scored hydrologic metric.

```{r MARSS1RegYVal, echo = F}
predict_eco = "juveniles per spawner"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
# if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# # Number of spawners included as predictor
# if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```



```{r MARSS_models_single_covar, echo = F}


# Specify MARSS model ------------------------------------------------------------------


## The code in the functions called below follows the R script
## Baruch_2023_Putah_Creek_MARSS.R, published in support of:
## Baruch et al., 2024. "Mimicking Functional Elements of the Natural Flow Regime
## Promotes Native Fish Recovery in a Regulated River." https://doi.org/10.1002/eap.3013.

model_list_file = "single cov MARSS models.rds"
coef_tab_file = "single cov marss coefs.csv"
aicc_tab_file = "single cov MARSS AICc tab.csv"

# extract season abbreviations from predictors
preds_season_list = strsplit(x = preds_screened, split = "_")
preds_season = unlist(lapply(X = preds_season_list, function(x){x[1]}))

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  coef_tab = read.csv(file.path(data_dir, coef_tab_file))
  
} else {
  # initialize results storage: AICc and coefficient tables and list of models
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  coef_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(coef_tab)=yvlt$y_val; rownames(coef_tab)=preds_screened
  
  list_of_mods = list()
  
  is = which(yvlt$y_val %in% c(y_val_coho, y_val_chinook))
  for(i in is){ #for coho and chinook juv abundance
    y_val_i = yvlt$y_val[i]
    # only run models for seasons that effect the selected ecological (y) value
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    # for each predictor in metrics_screened tab,
    for(j in 1:length(preds_for_y)){ 
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){ # there can be no missing covariate values
        # pull y-value table from metrics_tab
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        # fit a MARSS model (with the predictor as a single covariate) 
        marss_mod = get_single_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                       pred = pred_j)
        # add to list of models
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        # print(paste(y_val_i, "on", pred_j)) # track progress
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        coef_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        
      }
      
    }
  }
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))
  
  aicc_tab$pred = row.names(aicc_tab)
  coef_tab$pred = row.names(coef_tab)
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(coef_tab, file.path(data_dir, coef_tab_file), row.names = F)
}

```

```{r MARSSSingleCovarTableCoho, echo = F, warning =F, results = 'asis'}

aicc_order_co = order(aicc_tab[,y_val_coho])
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[aicc_order_co, "pred"])
results_y_co$coef = round(coef_tab[aicc_order_co, y_val_coho], 3)
results_y_co$aicc = round(aicc_tab[aicc_order_co, y_val_coho], 2)
colnames(results_y_co) = c("Covariate", "Coefficient", "AICc")
# make table for display
results_y_co_ft = results_y_co
didnt_model = is.na(results_y_co_ft$AICc)
results_y_co_ft$AICc[didnt_model] = "--"; results_y_co_ft$Coefficient[didnt_model] = "--"

caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")

coco_tab_ft = flextable(data=results_y_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 2)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 1)
coco_tab_ft


```


```{r MARSSSingleCovarTableChinook, echo = F, results = 'asis'}

aicc_order_ch = order(aicc_tab[,y_val_chinook])
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[aicc_order_ch, "pred"])
results_y_ch$coef = round(coef_tab[aicc_order_ch, y_val_chinook], 3)
results_y_ch$aicc = round(aicc_tab[aicc_order_ch, y_val_chinook], 2)
colnames(results_y_ch) = c("Covariate", "Coefficient", "AICc")
season_abbrev = substr(x = results_y_ch$Covariate, start = 1, stop = 2)
# make table for display
results_y_ch_ft = results_y_ch[!(season_abbrev %in% c("d2", "f2", "w2", "s2")),] # exclude predictors that don't temporally affect chinook smolt
didnt_model = is.na(results_y_ch_ft$AICc)
results_y_ch_ft$AICc[didnt_model] = "--"; results_y_ch_ft$Coefficient[didnt_model] = "--"


caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")


coch_tab_ft = flextable(data=results_y_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 1)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft



```

```{r MARSSSingleCovars, echo = F, warning = F, fig.height = 8, fig.cap = "Results of the three best single-hydrologic-covariate MARSS models to predict log-transformed Chinook and coho juvenile-per-spawners ratios with Z-scored hydrologic metrics.\\label{fig:MARSSSingleCovars}"}

n_mods = 3# for plot
top_cov_co = results_y_co$Covariate[order(results_y_co$AICc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_coho]))
pred_yrs_i_co = min(yrs_with_data):max(yrs_with_data)

top_cov_ch = results_y_ch$Covariate[order(results_y_ch$AICc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_chinook]))
pred_yrs_i_ch = min(yrs_with_data):max(yrs_with_data)


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_co,
                                   y_val = y_val_coho, top_cov = top_cov_co,
                                   top_models = top_mods_co)
  
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_ch,
                                   y_val = y_val_chinook, top_cov = top_cov_ch,
                                   top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```


## MARSS models of juveniles abundance, single hydrologic covariate

For purposes of statistical model comparison, we calculated multiple MARSS models (15 for coho and 8 for Chinook) that predicted juvenile abundance for coho and Chinook based on a single Z-scored hydrologic metric.

```{r MARSS2RegYVal, echo = F}
predict_eco = "juvenile abundance, hydro only"
# Hydro-only predictors
# if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
# if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```



```{r MARSS_juv_abun_models_single_covar, echo = F}


# Specify MARSS model ------------------------------------------------------------------


## The code in the functions called below follows the R script
## Baruch_2023_Putah_Creek_MARSS.R, published in support of:
## Baruch et al., 2024. "Mimicking Functional Elements of the Natural Flow Regime
## Promotes Native Fish Recovery in a Regulated River." https://doi.org/10.1002/eap.3013.

model_list_file = "juv abun single cov MARSS models.rds"
coef_tab_file = "juv abun single cov marss coefs.csv"
aicc_tab_file = "juv abun single cov MARSS AICc tab.csv"

# extract season abbreviations from predictors
preds_season_list = strsplit(x = preds_screened, split = "_")
preds_season = unlist(lapply(X = preds_season_list, function(x){x[1]}))

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  coef_tab = read.csv(file.path(data_dir, coef_tab_file))
  
} else {
  # initialize results storage: AICc and coefficient tables and list of models
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  coef_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(coef_tab)=yvlt$y_val; rownames(coef_tab)=preds_screened
  
  list_of_mods = list()
  
  is = which(yvlt$y_val %in% c(y_val_coho, y_val_chinook))
  for(i in is){ #for coho and chinook juv abundance
    y_val_i = yvlt$y_val[i]
    # only run models for seasons that effect the selected ecological (y) value
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    # for each predictor in metrics_screened tab,
    for(j in 1:length(preds_for_y)){ 
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){ # there can be no missing covariate values
        # pull y-value table from metrics_tab
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        # fit a MARSS model (with the predictor as a single covariate) 
        marss_mod = get_single_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                       pred = pred_j)
        # add to list of models
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        # print(paste(y_val_i, "on", pred_j)) # track progress
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        coef_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        
      }
      
    }
  }
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))
  
  aicc_tab$pred = row.names(aicc_tab)
  coef_tab$pred = row.names(coef_tab)
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(coef_tab, file.path(data_dir, coef_tab_file), row.names = F)
}

```

```{r MARSSJuvAbunSingleCovarTableCoho, echo = F, warning =F, results = 'asis'}

aicc_order_co = order(aicc_tab[,y_val_coho])
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[aicc_order_co, "pred"])
results_y_co$coef = round(coef_tab[aicc_order_co, y_val_coho], 3)
results_y_co$aicc = round(aicc_tab[aicc_order_co, y_val_coho], 2)
colnames(results_y_co) = c("Covariate", "Coefficient", "AICc")
# make table for display
results_y_co_ft = results_y_co
didnt_model = is.na(results_y_co_ft$AICc)
results_y_co_ft$AICc[didnt_model] = "--"; results_y_co_ft$Coefficient[didnt_model] = "--"

caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")

coco_tab_ft = flextable(data=results_y_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 2)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 1)
coco_tab_ft


```


```{r MARSSJuvAbunSingleCovarTableChinook, echo = F, results = 'asis'}

aicc_order_ch = order(aicc_tab[,y_val_chinook])
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[aicc_order_ch, "pred"])
results_y_ch$coef = round(coef_tab[aicc_order_ch, y_val_chinook], 3)
results_y_ch$aicc = round(aicc_tab[aicc_order_ch, y_val_chinook], 2)
colnames(results_y_ch) = c("Covariate", "Coefficient", "AICc")
season_abbrev = substr(x = results_y_ch$Covariate, start = 1, stop = 2)
# make table for display
results_y_ch_ft = results_y_ch[!(season_abbrev %in% c("d2", "f2", "w2", "s2")),] # exclude predictors that don't temporally affect chinook smolt
didnt_model = is.na(results_y_ch_ft$AICc)
results_y_ch_ft$AICc[didnt_model] = "--"; results_y_ch_ft$Coefficient[didnt_model] = "--"


caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")


coch_tab_ft = flextable(data=results_y_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 1)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft



```

```{r MARSSJuvAbunSingleCovars, echo = F, warning = F, fig.height = 8, fig.cap = "Results of the three best single-hydrologic-covariate MARSS models to predict log-transformed Chinook and coho outcomes with Z-scored hydrologic metrics.\\label{fig:MARSSJuvAbunSingleCovars}"}

n_mods = 3# for plot
top_cov_co = results_y_co$Covariate[order(results_y_co$AICc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_coho]))
pred_yrs_i_co = min(yrs_with_data):max(yrs_with_data)

top_cov_ch = results_y_ch$Covariate[order(results_y_ch$AICc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_chinook]))
pred_yrs_i_ch = min(yrs_with_data):max(yrs_with_data)


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_co,
                                   y_val = y_val_coho, top_cov = top_cov_co,
                                   top_models = top_mods_co)
  
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_ch,
                                   y_val = y_val_chinook, top_cov = top_cov_ch,
                                   top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```


## MARSS models of juvenile abundance, two covariates (spawner abundance and one hydrologic)

For purposes of statistical model comparison, we calculated multiple MARSS models (15 for coho and 8 for Chinook) that predicted juvenile abundance for coho and Chinook based on a single Z-scored hydrologic metric and Z-scored parental spawner abundance; thus, coefficients were calculated for both the hydrology and spawner covariates.

```{r MARSS3RegYVal, echo = F}
predict_eco = "juvenile abundance, hydro and spawners"
# Hydro-only predictors
# if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
# if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```

```{r newMetricsTabForMARSS3, echo = F}

metrics_tab = calc_metrics_hydro_by_affected_brood_year(
  hydro_by_brood_year = brood_year_hydro_tab,
  thresholds = thresh_for_corr_fig) 

# Clean metrics tab:
# 1) factorize water year category
metrics_tab$wy1_WY_Cat = as.numeric(factor(metrics_tab$wy1_WY_Cat,
                                           levels = c("dry year", "mod year", "wet year")))
metrics_tab$wy2_WY_Cat = as.numeric(factor(metrics_tab$wy2_WY_Cat,
                                           levels = c("dry year", "mod year", "wet year")))


yvlt = y_val_label_tab()
non_preds = c("brood_year", "smolt_year", yvlt$y_val)


if(zscore_flow_metrics == T){
  zscore_these = !(colnames(metrics_tab) %in% non_preds)
  metrics_mean = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = mean, na.rm=T)
  metrics_sd = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = sd, na.rm=T)
  metrics_tab[,zscore_these] = apply(X = metrics_tab[,zscore_these],
                                     MARGIN = 2, FUN = zscore_column_na_rm)
  
  if(predict_eco == "juvenile abundance, hydro and spawners"){
    # add spawners as a z-scored predictor variable
    metrics_tab$coho_spawners_zscored =
      zscore_column_na_rm(x = metrics_tab$coho_spawner_abundance)
    metrics_tab$chinook_spawners_zscored =
      zscore_column_na_rm(x = metrics_tab$chinook_spawner_abundance)
    non_preds = c(non_preds, "coho_spawners_zscored", "chinook_spawners_zscored")
    
  }
}

# transform data
if(log_transform_eco_metrics == T){
  metrics_tab[,yvlt$y_val] = log10(metrics_tab[,yvlt$y_val])
}



```



```{r MARSS_models_flow_and_spawn_covar, echo = F}

model_list_file = "flow and spawn MARSS models.rds"
flow_tab_file = "flow and spawn marss coefs_flow.csv"
spawn_tab_file = "flow and spawn marss coefs_spawn.csv"
aicc_tab_file = "flow and spawn AICc tab.csv"

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  flow_tab = read.csv(file.path(data_dir, flow_tab_file))
  spawn_tab = read.csv(file.path(data_dir, spawn_tab_file))
  
} else {
  
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  flow_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  spawn_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(flow_tab)=yvlt$y_val; rownames(flow_tab)=preds_screened
  colnames(spawn_tab)=yvlt$y_val; rownames(spawn_tab)=preds_screened
  
  
  smolts = c("coho_smolt_abun_est", "chinook_juvenile_abundance")
  spawns =  c("coho_spawners_zscored", "chinook_spawners_zscored")
  for(i in 1:2){
    y_val_i = smolts[i]
    y_val_spawn = spawns[i]
    # y_val_i = yvlt$y_val[smolts_i]
    # x_val_spawn = yvlt$y_val[spawn_i]
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[yvlt$y_val==y_val_i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    for(j in 1:length(preds_for_y)){
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        marss_mod = get_flow_and_spawn_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                               y_spawn_colname = y_val_spawn,
                                                               pred = pred_j)
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        flow_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        spawn_tab[row_finder, y_val_i] = marss_mod$coef["C.Spawners"]
        
      }
      # print(paste(y_val_i, "on", pred_j))
      # par(mfrow = c(4,2))
      # plot(marss_mod)
      
      # print(paste(y_val_i, "on", pred_j)) # track progress
      
    }
  }
  
  aicc_tab$pred = row.names(aicc_tab)
  flow_tab$pred = row.names(flow_tab)  
  spawn_tab$pred = row.names(spawn_tab)
  
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(flow_tab, file.path(data_dir, flow_tab_file), row.names = F)
  write.csv(spawn_tab, file.path(data_dir, spawn_tab_file), row.names = F)
}


```


```{r MARSSFlowAndSpawnCovarTableCoho, echo = F, results='asis'}

y_val = "coho_smolt_abun_est"
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
results_y_co$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
results_y_co$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_co$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_co$HtoSratio = round(results_y_co$flow / results_y_co$spawn,1)


afs_co_tab_ft = flextable(data=results_y_co)
caption_text = paste0("Characteristics of MARSS models of", yvlt$y_val_title[yvlt$y_val==y_val], "using one hydrologic metric as the single covariate in each model.")


afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=1,  width = 2.5)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=3,  width = 1)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=4,  width = 1)
afs_co_tab_ft = flextable::set_header_labels(afs_co_tab_ft,
                                             values = list(
                                               pred = "Hydrologic Covariate",
                                               aicc = "AICc",
                                               flow ="Hydro Coef.",
                                               spawn = "Spawner Coef."))
afs_co_tab_ft
```


```{r MARSSFlowAndSpawnCovarTableChinook, echo = F, results='asis'}
y_val = "chinook_juvenile_abundance"
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
results_y_ch$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
results_y_ch$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_ch$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 4)
results_y_ch$HtoS_ratio = round(results_y_ch$flow / results_y_ch$spawn,1)


afs_ch_tab_ft = flextable(data=results_y_ch)
caption_text = paste0("Characteristics of MARSS models of", yvlt$y_val_title[yvlt$y_val==y_val], "using one hydrologic metric as the single covariate in each model.")
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=1,  width = 2.5)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=3,  width = 1)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=4,  width = 1)
afs_ch_tab_ft = flextable::set_header_labels(afs_ch_tab_ft,
                                             values = list(
                                               pred = "Hydrologic Covariate",
                                               aicc = "AICc",
                                               flow ="Hydro Coef.",
                                               spawn = "Spawner Coef."))

afs_ch_tab_ft
```

```{r MARSSHydroPlusSpawn, echo = F, warning = F, fig.height = 8, fig.cap = "Results of MARSS to predict log-transformed juvenile abundance for coho and Chinook outcomes with Z-scored hydrologic metrics plus spawner data.\\label{fig:MARSSHydroPlusSpawn}"}

n_mods = 3# for plot
top_cov_co = results_y_co$pred[order(results_y_co$aicc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data_yval = which(!is.na(metrics_tab[,y_val_coho]))
yrs_with_data_spawn = which(!is.na(metrics_tab[,"coho_spawners_zscored"]))
pred_yrs_i_co = min(yrs_with_data_spawn):max(yrs_with_data_yval)

top_cov_ch = results_y_ch$pred[order(results_y_ch$aicc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data_yval = which(!is.na(metrics_tab[,y_val_chinook]))
yrs_with_data_spawn = which(!is.na(metrics_tab[,"chinook_spawners_zscored"]))
pred_yrs_i_ch = min(yrs_with_data_spawn):max(yrs_with_data_yval)


fig_path = file.path(save_figs_here, paste0("Figure S",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_flow_and_spawn(metrics_tab = metrics_tab,
                                    pred_yrs_i = pred_yrs_i_co,
                                    y_val = y_val_coho, 
                                    top_cov = top_cov_co,
                                    top_models = top_mods_co)
  
  marss_predict_plot_flow_and_spawn(metrics_tab = metrics_tab,
                                    pred_yrs_i = pred_yrs_i_ch,
                                    y_val = y_val_chinook, 
                                    top_cov = top_cov_ch,
                                    top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```




# References

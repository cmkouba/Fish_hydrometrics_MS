---
title: Supplement to "A watershed-specific formula to predict salmon reproduction using functional flow metrics"
author: "Claire Kouba, Jason Wiener, Leland Scantlebury and Thomas Harter"
date: "Feb. 2025"
output: 
  bookdown::word_document2: 
    fig_caption: true
    number_sections: true
    global_numbering: true
bibliography: draft_library.bib
---

```{r supp_setup_dirs_load_data, include = FALSE}


knitr::opts_chunk$set(echo = TRUE)

# dev_mode = run by itself; dev_mode = F if you are calling it from the main .Rmd
dev_mode = T

if(dev_mode){
  # libraries
  library(lubridate)
  library(httr)
  library(ggplot2) # for barplots 
  library(gridExtra)
  library(corrplot)  # for data exploration/correlation plots
  library(dataRetrieval) # for usgs data
  library(data.table) #month function
  library(zoo) # rolling means
  library(sf)
  library(terra)
  library(tmap)
  library(grid) # for inset maps
  library(cowplot) # for inset maps
  library(ggthemes) # for colorblind palette
  library(flextable)
  library(glmnet) # lasso regression
  library(MARSS)
  library(here)
  
  # Directories
  ms_dir = here::here()
  scratch_dir = file.path(ms_dir, "scratch_work")
  data_dir = file.path(ms_dir, "Data")
  graphics_dir = file.path(ms_dir, "Graphics and Supplements")
  
  # Load spatial and tabular data
  
  # If the data files don't exist locally,
  # pull data from internet and local files
  if(!file.exists(file.path(ms_dir,"manuscript_data.RData"))){
    source(file.path(ms_dir,"01_DataRetrieval_Cleaning_SaveLocal.R")) 
  }
  
  load(file.path(ms_dir, "manuscript_data.RData")) # Load data layers/tables
  source(file.path(ms_dir,"02_Figure_Functions.R"))   # Load figure and table functions
  
  # Save figures as images, yes or no?
  save_figs_here = graphics_dir
  save_imgs=T # generate the figures in the folder
  include_figs = T
  replace_setting_fig = F # setting to F can save time if no need to re-render map
  fig_i = 100
  
  # pick last water year for the HB function to calculate a value for
  last_wy = 2023
}

```

```{r lassoRegYVal, echo = F}
predict_eco = "juvenile abundance, hydro and spawners"# "juveniles per spawner"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```

```{r supp_load_FF_metrics, include = FALSE}

if(dev_mode){
  log_transform_eco_metrics = T
  zscore_flow_metrics = T
  fflows = read_fflows_FJ(calculator = "Flashy")
# fflows = read_fflows_FJ(calculator = "Regular")

  # produce metrics_tab

  brood_year_hydro_tab = tabulate_hydro_by_affected_brood_year(brood_years = 1999:2022,
                                                               smolt_years = 2001:2024)
  thresh_for_corr_fig = c(20,40,120)
  
  metrics_tab = calc_metrics_hydro_by_affected_brood_year(
    hydro_by_brood_year = brood_year_hydro_tab,
    thresholds = thresh_for_corr_fig) 
  
  # Clean metrics tab:
  # 1) factorize water year category
  metrics_tab$wy1_WY_Cat = as.numeric(factor(metrics_tab$wy1_WY_Cat,
                                             levels = c("dry year", "mod year", "wet year")))
  metrics_tab$wy2_WY_Cat = as.numeric(factor(metrics_tab$wy2_WY_Cat,
                                             levels = c("dry year", "mod year", "wet year")))
  
  
  yvlt = y_val_label_tab()
  non_preds = c("brood_year", "smolt_year", yvlt$y_val)
  
  
  if(zscore_flow_metrics == T){
    zscore_these = !(colnames(metrics_tab) %in% non_preds)
    metrics_mean = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = mean, na.rm=T)
    metrics_sd = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = sd, na.rm=T)
    metrics_tab[,zscore_these] = apply(X = metrics_tab[,zscore_these],
                                       MARGIN = 2, FUN = zscore_column_na_rm)
    
    if(predict_eco == "juvenile abundance, hydro and spawners"){
        # add spawners as a z-scored predictor variable
    metrics_tab$coho_spawners_zscored =
      zscore_column_na_rm(x = metrics_tab$coho_spawner_abundance)
    metrics_tab$chinook_spawners_zscored =
      zscore_column_na_rm(x = metrics_tab$chinook_spawner_abundance)
    non_preds = c(non_preds, "coho_spawners_zscored", "chinook_spawners_zscored")

    }
  }
  
  # transform data
  if(log_transform_eco_metrics == T){
    metrics_tab[,yvlt$y_val] = log10(metrics_tab[,yvlt$y_val])
  }
  
  
  # for z-scored x metrics, on 5/19/2025
  screened_cols = c("brood_year","smolt_year",
                    "coho_smolt_per_fem", "chinook_juv_per_adult",
                    "coho_spawner_abundance", "coho_redds_in_brood",
                    "coho_smolt_abun_est", "chinook_spawner_abundance",
                    "chinook_juvenile_abundance", "f2_recon_120",
                    "d1_DS_Mag_50", "d1_DS_Mag_90", "f1_FA_Dur",
                    "f1_FA_Tim", "f1_FA_Dif_num", "w1_Wet_BFL_Dur",
                    "w1_Wet_BFL_Mag_50", "s1_SP_ROC", "s1_SP_ROC_Max",
                    "f2_FA_Dur", "f2_FA_Dif_num", "w2_Wet_BFL_Mag_50",
                    "w2_Wet_Tim", "s2_SP_ROC", "s2_SP_ROC_Max",
                    "s2_SP_Tim", "f1_recon_120")
  screened_cols_ch = c("brood_year","smolt_year",
                       "coho_smolt_per_fem", "chinook_juv_per_adult",
                       "coho_spawner_abundance", "coho_redds_in_brood",
                       "coho_smolt_abun_est", "chinook_spawner_abundance",
                       "chinook_juvenile_abundance", #"f2_recon_120",
                       "d1_DS_Mag_50", "d1_DS_Mag_90", "f1_FA_Dur",
                       "f1_FA_Tim", "f1_FA_Dif_num", "w1_Wet_BFL_Dur",
                       "w1_Wet_BFL_Mag_50", "s1_SP_ROC", "s1_SP_ROC_Max",
                       #"f2_FA_Dur", "f2_FA_Dif_num", "w2_Wet_BFL_Mag_50",
                       #"w2_Wet_Tim", "s2_SP_ROC", "s2_SP_ROC_Max",
                       #"s2_SP_Tim", 
                       "f1_recon_120")
  if(predict_eco == "juvenile abundance, hydro and spawners"){
    screened_cols = c(screened_cols, "coho_spawners_zscored","chinook_spawners_zscored")
    screened_cols_ch = c(screened_cols_ch, "coho_spawners_zscored","chinook_spawners_zscored")
  }
  
  preds_screened = screened_cols[!(screened_cols %in% non_preds)]
  metrics_tab_screened = metrics_tab[,screened_cols]
  metrics_tab_screened_chinook = metrics_tab[,screened_cols_ch]
  
  
}
```


# Scott River watershed setting and water use

## Geography, climate and hydrology

The Scott River drains a 2,109 km^2^ (814 square mile) watershed known as Scott Valley, flowing generally from south to north and joining the Klamath River after flowing through a steep canyon (Figure \@ref(fig:ScottWatershedMap)). The Scott is a major tributary to the Klamath, which drains an area spanning sections of Northern California and Southern Oregon (Figure \@ref(fig:ScottWatershedMap), inset map). Scott Valley has a Mediterranean climate with distinctive seasons of cool, wet winters and warm, dry summers. This seasonality in water input creates highly seasonal flow in the Scott River and tributary streams, where the beginning of a water year coincides with low flow conditions that immediately precede the onset of winter precipitation (Figure \@ref(fig:fjFlowFigure)). 

In most dry-to-average water years, sections of the Scott River become seasonally dewatered [NCRWQCB -@NorthCoastRegionalWaterQualityControlBoardStaff2005; Figure 5 in @TolleyEtAlSensitivity2019]. This occurs when the elevation of the water table drops below the bottom of the river channel, as streams and groundwater are highly interconnected in the Scott River watershed. Tributary streams, particularly along their alluvial fan apeces, and the upper Scott River are sources of recharge to the aquifer [@MackGeology1958; @HarterHinesSCOTT2008]. Groundwater discharge sustains streamflow in low-lying areas, especially during the dry season of August through October or November [@TolleyEtAlSensitivity2019]. For consistency with regulatory and management programs in this region, this document uses units of cubic feet per second (cfs) when reporting hydrologic fluxes.

```{r fjFlowFigure, echo=FALSE, fig.cap="Each translucent line traces one annual hydrograph measured at the Fort Jones gauge, and the darker lines illustrate the 30-day smoothed median daily flow in Dry, Below Average, Above Average, and Wet water year types, for water years 1942-2023. The water year type is defined by quartiles of the distribution of total annual flow.", warning=F}

fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 6, units = "in", res = res_dpi)
  
  fj_flow_figure(roll_window = 30)
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```

## Water uses and management objectives

Water in Scott Valley is used for agricultural, domestic, and municipal supply. It also facilitates recreation and provides Native American cultural services, among other designated beneficial uses [NCRWQCB -@NorthCoastRegionalWaterQualityControlBoardACTION2006]. Because the watershed is undammed, managers and water users influence Scott River flow primarily via diversion of surface waters and pumping of groundwater. Consequently, the most powerful tool available to manage Scott River water flow is regulation of land use and thus water demand [Siskiyou County -@SiskiyouCountyScott2021]. 

Historically, local regulation of land use has focused on maintaining the rural and agricultural character of Scott Valley [@ScottValleyAreaPlanCommitteeScott1980]. Regulating land use to improve ecological outcomes would entail significant economic, political and social risks, because much of the economic activity in this area is related to agriculture. The primary crops grown in Scott Valley are pasture for cattle feed and alfalfa [Siskiyou County -@SiskiyouCountyScott2021]. In addition to local economic impact, Scott River conditions influence fish population dynamics both within the watershed and in the broader Klamath system. The health of the Klamath salmon run has implications for commercial fishing, recreational activities, and cultural practices of Native American tribes in the region, including the Quartz Valley Indian Community and the Karuk and Yurok Tribes [@MansfieldEtAlKlamath2012].

# Species of concern - coho and Chinook salmon

### Life cycle and status of coho salmon (*Oncorhynchus kisutch*)

Returning adult coho spawn in natal streams between November and January [@KnechtleGiudice20192020], and juvenile coho spend approximately one full year in freshwater streams before migrating to the ocean as smolts [@MoyleCoho2002; @McMahonHabitat1983]. In the Scott River system these natal streams are the tributaries along the margins of the valley floor [SRCD -@SiskiyouResourceConservationDistrictFinal2004].

In previous studies, the strongest predictor of juvenile coho abundance in a stream system was spatial habitat [@BradfordEtAlEmpirical1997; @NickelsonEtAlSeasonal1992; @BustardNarverAspects1975], although adequate food and cover were also important [@McMahonHabitat1983]. The primary mechanism for spatial constraints on abundance appears to be that juvenile coho become more territorial as they grow [@McMahonHabitat1983].

Some coho salmon return to spawn at age 2 as grilse, but the majority (e.g., 92.4% in 2020) return after more than one year in the ocean, giving the Scott coho salmon run its characteristic 3-year cohort return interval [@KnechtleGiudice20192020].

Coho salmon in the Scott Valley are listed as threatened under the federal and California Endangered Species Acts (ESAs). They belong to the Southern Oregon / Northern California Coast (SONCC) Evolutionarily Significant Unit (ESU), which was listed as threatened under the federal and state ESAs in 1997 and 2005, respectively. State-wide, coho populations have declined more than 90% since the 1940s [@BrownEtAlHistorical1994]. 

### Life cycle and status of Chinook salmon (*Onchorhynchus tsawytscha*)

Chinook salmon in the Scott Valley are a candidate for listing under the federal ESA, and are not listed under the California ESA. They belong to the Southern Oregon / Northern California Coast (SONCC) Evolutionarily Significant Unit (ESU). 
Typically, adult Chinook salmon return to spawn in Scott Valley streams in the fall months September-December when flows are sufficient for salmon passage [@KnechtleGiudice20192020; @MagranetScott2015a; @MagranetScott2017]. Chinook in this watershed hatch in the spring and migrate to the ocean in their first year of life [@AgrawalEtAlPREDICTING2005]. Chinook spend the majority of their life in the ocean, and return to their natal streams shortly before spawning [@GrootMargolisLife1991]. However, substantial variability exists within this broader structure: Chinook salmon exhibit variation in multiple life stages, including time of seaward migration, age of maturity, and timing of return to natal stream [@GrootMargolisLife1991; @BourretEtAlDiversity2016].

As recently as 2013, the SONCC Chinook population was stable and becoming more complex [@WainwrightEtAlCCIEA2013]. However, in monitoring from 2015-2020, the number of returning adults (the escapement) was 65% below historical average, and the change in the Scott River Chinook population has been more rapid than the decline in the overall Klamath Basin Chinook run [@CaliforniaDepartmentofFishandWildlifeScott2021]. Ocean conditions may have contributed to a broad decline in Chinook populations from Alaska to California [@WelchEtAlSynthesis2021]. Some studies have found that the leading cause of declining Chinook populations are ocean conditions, including including temperature, upwelling currents and food resources [@HuntEtAlOceanic1999], while others have identified hatchery practices as the primary cause [@QuinonesEtAlPotential2014]. 


# Functional Flows Background
```{r funcFlowTermsTab, echo = FALSE, results = 'asis'}

ff_tab = read.csv(file.path(data_dir,"Hydro Metrics Table_Functional Flows.csv"))

#Create caption and column labels
caption_text = "TO UPDATE. Explanation of hydrologic metrics used in this analysis. Each type of metric, for each threshold value (e.g., 100 cfs or 50th flow percentile), produces one value per water year. Example metric names also include abbreviations for salmon life periods described in Table 2 below."
column_labels = c("Abbrev.","Full Name", "Thresholds","Description")
colnames(ff_tab) = column_labels

ff_tab_ft = flextable(data=ff_tab)
ff_tab_ft = set_caption(ff_tab_ft, caption = caption_text)
ff_tab_ft = flextable::width(ff_tab_ft,j=1,  width = 1.3)
ff_tab_ft = flextable::width(ff_tab_ft,j=2,  width = 1.5)
ff_tab_ft = flextable::width(ff_tab_ft,j=3, width = 1)
ff_tab_ft = flextable::width(ff_tab_ft,j=4,  width = 3.1)
ff_tab_ft

``` 


```{r fig2Yarnell2020, echo = F, message = F, warning =F, fig.height = 8.5, fig.cap = "Figure 2 from Yarnell et al., 2020. Illustration of five functional flow categories identified for a mixed rain-snowmelt runoff river in California."}

if(save_imgs==T){
  file.copy(from = file.path(graphics_dir, "Graphics source", "Yarnell2020_Fig2.png"),
            to = file.path(save_figs_here, paste0("Figure ",fig_i,".png")))
}

if(include_figs==T){
knitr::include_graphics(file.path(save_figs_here, paste0("Figure ",fig_i,".png")))
}


fig_i = fig_i +1

```


# Hydrologic Metrics Designed for This Study

```{r customHydroMetricsTab, echo = FALSE, results = 'asis'}

ff_tab = read.csv(file.path(data_dir,"Hydro Metrics Table_Custom metrics.csv"))

#Create caption and column labels
caption_text = "Explanation of custom hydrologic metrics designed for this study, which are less complex than functional flows in that they do not rely on signal processing techniques. Each type of metric, for each threshold value (e.g., 120 cfs), produces one value per water year. Metric names used in predictive modeling also include abbreviations for salmon life periods (Table 3 below); e.g., f1_recon_120, referring to the timing of flow exceeding 120 cfs in a ohort's first fall season."
column_labels = c("Abbrev.","Full Name", "Thresholds","Description")
colnames(ff_tab) = column_labels

ff_tab_ft = flextable(data=ff_tab)
ff_tab_ft = set_caption(ff_tab_ft, caption = caption_text)
ff_tab_ft = flextable::width(ff_tab_ft,j=1,  width = 1.1)
ff_tab_ft = flextable::width(ff_tab_ft,j=2,  width = 1.5)
ff_tab_ft = flextable::width(ff_tab_ft,j=3, width = 1)
ff_tab_ft = flextable::width(ff_tab_ft,j=4,  width = 3.2)
ff_tab_ft

```  


```{r reconnectExplainerHydrograph, echo = F, warning =F, fig.cap = "Reconnection and disconnection dates are highlighted for one water year. Two example thresholds, 20 and 120 cfs (0.57 and 3.4 cms, respectively) are highlighted, which correspond to distinct river connectivity (and salmon habitat access) conditions in the Scott River watershed as observed at the Fort Jones gauge (see Results for more detail on selection of flow thresholds)."}


fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 4.5, units = "in", res = res_dpi)
  
recon_and_discon_explainer_hydrograph(
  water_year = 2016, tot_flow_annotate = F, 
  connection_date_annotate = "20_and_120_only")
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```

# Screening Predictors for Collinearity

## Groups 1 and 2

These metrics describe the magnitude and timing of wet-season flows (years 1 and 2), effectively characterized by the question, how wet was the wet season?. We selected `w1_Wet_BFL_Mag_50` and `w2_Wet_BFL_Mag_50` as the most conceptually central metric to represent the amount of water passing through the watershed during two wet seasons: `w1`, the first wet season, experienced by a cohort as eggs and newly-hatched alevin and fry, and `w2`, experienced by the cohort as overwintering parr.

## Group 3

These metrics describe the magnitude and timing of dry-season flows before the cohort's spawning. We selected `d1_DS_Mag_50` as the most conceptually central metric to represent the amount of water passing through the watershed during the dry season before a cohort's parents' spawning.

## Groups 4 and 5

These metrics quantify the timing of the wet season onset and duration (year 2). We selected `w2_Wet_Tim`, the timing of the onset of the second wet season, and `w2_Wet_BFL_Dur`, the duration of wet season baseflow, to characterize the timing of the wet season experienced by a cohort of coho as overwintering juveniles.

## Groups 6 and 7: 

These metrics quantify the magnitude of the fall pulse flow (years 1 and 2). Although `FA_num_diff` had a higher sample size, we selected `f1_FA_Mag` and `f2_FA_Mag` to better reflect the years in which an identifiable fall pulse occurred before the onset of the wet season.


# Ecological Data Features

Plot spawners vs juveniles and spawners vs redds (color coded by year?)

Plot ACF for each eco record

```{r acfEcoRecords, echo = F, warning = F, fig.height = 8, fig.cap = "Autocorrelation function estimates for all available ecological outcome records.\\label{fig:acfEcoRecords}"}

fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

par(mfrow = c(3,3))
for(i in 1:nrow(yvlt)){
  y_i = yvlt$y_val[i]
  y_vals_continuous = get_longest_cont_ts(y = metrics_tab[,y_i], 
                                          y_years = metrics_tab$brood_year)
  acf(x = y_vals_continuous$y_cont,
      main = yvlt$y_val_label[i],
      sub = paste0("Continuous record length: ",nrow(y_vals_continuous), " years"))
}


if(save_imgs == TRUE){dev.off()}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1
```

# Statistical Method Details

<!-- ## Ridge Regression -->


<!-- ```{r kfold_lambda_finding_ridge, echo = FALSE} -->

<!-- # calculate lasso regression model and cross-validation objects -->
<!-- # (lasso: alpha = 1; ridge: alpha = 0) -->
<!-- mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened, y_val = y_val_coho, -->
<!--                       alpha = 0) -->
<!-- mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv -->

<!-- mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha = 0,  -->
<!--                       y_val = y_val_chinook) -->
<!-- mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv -->

<!-- # extract coefficients from the model using the optimal lambda value found in cross-validation -->
<!-- if(predict_eco == "juveniles per spawner"){ -->
<!--   alt_lambda_co = .135 -->
<!--   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3, -->
<!--                             alt_lambda = alt_lambda_co) -->
<!--   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3) -->

<!-- } else if(predict_eco == "juvenile abundance, hydro and spawners"){ -->
<!--   alt_lambda_co = .022 -->
<!--   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3, -->
<!--                             alt_lambda = alt_lambda_co) -->
<!--   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3) -->

<!-- } else { -->
<!--   coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3) -->
<!--   coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3) -->

<!-- } -->




<!-- ``` -->


<!-- ```{r ridgeResultsCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:lassoResultsChinook}"} -->

<!-- fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png")) -->
<!-- if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)} -->

<!-- if(predict_eco == "juveniles per spawner"){ -->
<!--   # do nothing -->
<!--   # lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch, -->
<!--   #               alt_lambda_co = alt_lambda_co) -->
<!-- } else if (predict_eco == "juvenile abundance, hydro and spawners"){ -->
<!--     lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch, -->
<!--                 alt_lambda_co = alt_lambda_co) -->
<!-- } else if (predict_eco == "juvenile abundance, hydro only"){ -->
<!--   lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch) -->
<!-- } -->

<!-- if(save_imgs == TRUE){ -->
<!--   dev.off() -->
<!-- } -->
<!-- if(include_figs==T){knitr::include_graphics(fig_path)} -->
<!-- fig_i = fig_i +1 -->

<!-- ``` -->


<!-- ```{r ridgeCoefTableCoho, echo = F, warning =F, results = 'asis'} -->

<!-- # Retrieve coefficients from lasso model -->

<!-- coefs_interp_names = names(coefs_co$coef_non0_only) -->
<!-- coefs_interp = as.character(coefs_co$coef_non0_only) -->
<!-- names(coefs_interp) = coefs_interp_names -->
<!-- # add interpretation to each non-0 coefficient -->
<!-- # if(y_val_coho == "coho_smolt_per_fem" & log_transform_eco_metrics == F & zscore_flow_metrics == T){ -->
<!-- #   coefs_interp$f1_recon_120 = "Earlier full-system reconnection (120 cfs, fall of parents' spawning)" -->
<!-- #   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and fry)" -->
<!-- #   coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)" -->
<!-- # } -->
<!-- # if(y_val_coho == "coho_smolt_per_fem" & log_transform_eco_metrics == T & zscore_flow_metrics == T){ -->
<!-- #     coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)" -->
<!-- #     coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)" -->
<!-- #     coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)" -->
<!-- #     coefs_interp$s2_SP_ROC = "Faster rate of change (as outmigrating smolt)" -->
<!-- # } -->
<!-- # if(y_val_coho == "coho_smolt_abun_est" & log_transform_eco_metrics == F & zscore_flow_metrics == T){ -->
<!-- #   coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)" -->
<!-- #   coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)" -->
<!-- # } -->
<!-- coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)" -->
<!-- coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)" -->
<!-- coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)" -->
<!-- coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)" -->
<!-- coefs_interp$w2_Wet_BFL_Mag_50 = "Lower wet season baseflows (as overwintering juveniles)" -->
<!-- coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)" -->
<!-- coefs_interp$w1_Wet_BFL_Mag_50 = "Higher wet season baseflows (as eggs and hatchlings)" -->
<!-- # coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as recent hatchlings)" -->
<!-- coefs_interp$d1_DS_Mag_50 = "Higher dry season median flows (before parents' spawning)" -->
<!-- coefs_interp$s2_SP_Tim = "Earlier spring recession onset (as outmigrating smolt)" -->
<!-- coefs_interp$w2_Wet_Tim = "Later wet season onset (as overwintering juveniles)" -->
<!-- coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)" -->
<!-- coefs_interp$f2_recon_120 = "Earlier fall reconnection (as juvenile fish)" -->
<!-- coefs_interp$d1_DS_Mag_90 = "Higher dry season high flows (before parents' spawning)" -->
<!-- # coefs_interp$s2_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)" -->

<!-- if(predict_eco == "juvenile abundance, hydro and spawners"){ -->
<!--   coefs_interp$coho_spawner_abundance = "More spawners (cohort's parents)" -->
<!-- } -->
<!-- coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3)) -->
<!-- coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"])) -->
<!-- coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)), -->
<!--                          Value = as.vector(coefs_co_vals), -->
<!--                          Description = coefs_co_interp) -->

<!-- caption_text = "Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated coho juvenile abundance, including a description of which phenomena are associated with higher ecological outcome values." -->

<!-- coco_tab_ft = flextable(data=coefs_co_ft) -->
<!-- coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text) -->
<!-- coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.5) -->
<!-- coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1) -->
<!-- coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3) -->
<!-- coco_tab_ft = flextable::set_header_labels(coco_tab_ft, -->
<!--                                            values = list( -->
<!--                                              Predictor ="Predictor",  -->
<!--                                              Value = "Value", -->
<!--                                              Description = "Greater Hydrologic Benefit value associated with")) -->
<!-- coco_tab_ft -->


<!-- ``` -->


<!-- ```{r ridgeCoefTableChinook, echo = F, warning =F, results = 'asis'} -->

<!-- # Retrieve coefficients from ridge model -->

<!-- coefs_interp_names = names(coefs_ch$coef_non0_only) -->
<!-- coefs_interp = as.character(coefs_ch$coef_non0_only) -->
<!-- names(coefs_interp) = coefs_interp_names -->
<!-- # add interpretation to each non-0 coefficient -->
<!-- if(y_val_chinook == "chinook_juvenile_abundance" & log_transform_eco_metrics == T & zscore_flow_metrics == T){ -->
<!--   coefs_interp$f1_FA_Dif_num = "Smaller fall flow increase (during parents' spawning)" -->
<!--   coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as outmigrating smolt)" -->
<!--   coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)" -->
<!--   coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)" -->
<!--   coefs_interp$d1_DS_Mag_50 = "Higher dry season median flows (before parents' spawning)" -->
<!--   coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)" -->
<!--   coefs_interp$d1_DS_Mag_90 = "Lower dry season high flows (before parents' spawning)" -->
<!--   coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)" -->
<!-- } -->

<!-- coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3)) -->
<!-- coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"])) -->
<!-- coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)), -->
<!--                          Value = as.vector(coefs_ch_vals), -->
<!--                          Description = coefs_ch_interp) -->

<!-- caption_text = "Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated Chinook juvenile abundance, including a description of which phenomena are associated with higher ecological outcome values." -->

<!-- coch_tab_ft = flextable(data=coefs_ch_ft) -->
<!-- coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text) -->
<!-- coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 1.5) -->
<!-- coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1) -->
<!-- coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3) -->
<!-- coch_tab_ft = flextable::set_header_labels(coch_tab_ft, -->
<!--                                            values = list( -->
<!--                                              Predictor ="Predictor",  -->
<!--                                              Value = "Value", -->
<!--                                              Description = "Greater Hydrologic Benefit value associated with")) -->
<!-- coch_tab_ft -->


<!-- ``` -->


## Lasso Regression, juvenile abundance on hydro. and spawners

```{r alt_lasso_analysis, echo = FALSE}

# calculate lasso regression model and cross-validation objects
# (lasso: alpha = 1; ridge: alpha = 0)\
if(predict_eco == "juveniles per spawner"){
  mod_obj_co = kfold_cv(mt = metrics_tab_screened, 
                        y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv(mt = metrics_tab_screened_chinook, alpha =1, 
                        y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  
  alt_lambda_co = .135
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
  
} else if(predict_eco == "juvenile abundance, hydro and spawners"){
  mod_obj_co = kfold_cv_plus_spawn(mt = metrics_tab_screened, 
                                   y_val = y_val_coho, alpha = 1)
  mod_co = mod_obj_co$mod; cv_co = mod_obj_co$cv
  mod_obj_ch = kfold_cv_plus_spawn(mt = metrics_tab_screened_chinook, alpha =1, 
                                   y_val = y_val_chinook)
  mod_ch = mod_obj_ch$mod; cv_ch = mod_obj_ch$cv
  # extract coefficients from the model using the optimal lambda value found in cross-validation
  alt_lambda_co = .135
  coefs_co = get_pred_coefs(mod = mod_co, cv = cv_co, coef_digits = 3
                            # , alt_lambda = alt_lambda_co
  )
  coefs_ch = get_pred_coefs(mod = mod_ch, cv = cv_ch, coef_digits = 3)
  
}





```


```{r jpsLassoCohoChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of lasso regression to predict log-transformed coho and Chinook outcomes with Z-scored hydrologic metrics. Models with more coefficients explain a greater fraction of deviance in the dataset (middle panel), but also produce higher test errors (top panel), indicating some overfitting at lower lambda values. Higher values of lambda tend to shrink the absolute values of regression coefficients toward 0 (bottom panel).\\label{fig:jpsLassoCohoChinook}"}

fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png"))
if(save_imgs == TRUE){png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)}

if(predict_eco == "juvenile abundance, hydro and spawners"){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch)
} else if(predict_eco == "juveniles per spawner"){
  lasso_results(cv_co = cv_co, cv_ch = cv_ch, mod_co = mod_co, mod_ch = mod_ch,
                alt_lambda_co = alt_lambda_co)
}

if(save_imgs == TRUE){
  dev.off()
  # pred_tab_filename = "Supplemental Table 3. Coho Salmon Lasso Coefficients.csv"
  # write.csv(x=coefs_co$coef_all, file=file.path(graphics_dir,pred_tab_filename),
  #           quote=F, row.names = F)
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1

```


```{r jpsCoefTableCoho, echo = F, warning =F, results = 'asis'}

# Retrieve coefficients from lasso model

coefs_interp_names = names(coefs_co$coef_non0_only)
coefs_interp = as.character(coefs_co$coef_non0_only)
names(coefs_interp) = coefs_interp_names

if(predict_eco == "juvenile abundance, hydro and spawners"){
  # coefs_interp$coho_spawner_abundance = "Number of spawners (cohort's parents)"
  # coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
  coefs_interp$f2_FA_Dif_num = "Smaller fall flow increase (as juvenile fish)"
  coefs_interp$f1_FA_Dif_num = "Larger fall flow increase (during parents' spawning)"
  # coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolt)"
  # coefs_interp$w2_Wet_BFL_Mag_50 = "Higher wet season baseflows (as overwintering juveniles)"
  coefs_interp$s1_SP_ROC = "Slower rate of change, spring recession (as recent hatchlings)"
} 
if(predict_eco == "juveniles per spawner"){
  coefs_interp$f1_recon_120 = "Earlier fall reconnection (during parents' spawning)"
  coefs_interp$f2_FA_Dif_num = "Smaller fall pulse (as juvenile fish)"
  coefs_interp$s2_SP_ROC = "Faster rate of change, spring recession (as outmigrating smolts)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season (as eggs and hatchlings)"
}

coefs_co_vals = c(round(coefs_co$int_and_coefs$coef, 3))
coefs_co_interp = c("(Intercept)", unlist(coefs_interp[coefs_co!="0"]))
coefs_co_ft = data.frame(Predictor = c(names(coefs_co_interp)),
                         Value = as.vector(coefs_co_vals),
                         Description = coefs_co_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated ",
y_val_coho,", including a description of which phenomena are associated with higher ecological outcome values.")

coco_tab_ft = flextable(data=coefs_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 1.5)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 3)
coco_tab_ft = flextable::set_header_labels(coco_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coco_tab_ft


```


```{r jpsCoefTableChinook, echo = F, warning =F, results = 'asis'}

coefs_interp_names = names(coefs_ch$coef_non0_only)
coefs_interp = as.character(coefs_ch$coef_non0_only)
names(coefs_interp) = coefs_interp_names
# add interpretation to each non-0 coefficient
if(predict_eco == "juvenile abundance, hydro and spawners"){
  coefs_interp$chinook_spawners_zscored = "Abundance of spawners (parents of designated cohort)"
  coefs_interp$w1_Wet_BFL_Mag_50 = "Lower wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season baseflow duration (as eggs and hatchlings)"
}
if(predict_eco == "juveniles per spawner"){
  coefs_interp$w1_Wet_BFL_Mag_50 = "Smaller wet season baseflows (as eggs and hatchlings)"
  coefs_interp$s1_SP_ROC_Max = "Slower max. rate of change, spring recession (as outmigrating smolt)"
  coefs_interp$w1_Wet_BFL_Dur = "Longer wet season duration (as eggs and hatchlings)"
}
coefs_ch_vals = c(round(coefs_ch$int_and_coefs$coef, 3))
coefs_ch_interp = c("(Intercept)", unlist(coefs_interp[coefs_ch!="0"]))
coefs_ch_ft = data.frame(Predictor = c(names(coefs_ch_interp)),
                         Value = as.vector(coefs_ch_vals),
                         Description = coefs_ch_interp)

caption_text = paste0("Values for the intercept and coefficient terms in the Hydrologic Benefit function for estimated",
                      y_val_chinook,", including a description of which hydrologic phenomena are associated with higher ecological outcome values.")

coch_tab_ft = flextable(data=coefs_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 1.5)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 3)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft


```


## MARSS Models


### MARSS models of juveniles per spawner, single hydrologic covariate

Multi-variate autoregressive state-space (MARSS) models are often used to model time series data (in which )

```{r MARSS1RegYVal, echo = F}
predict_eco = "juveniles per spawner"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
# if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```



```{r MARSS_models_single_covar, echo = F}


# Specify MARSS model ------------------------------------------------------------------


## The code in the functions called below follows the R script
## Baruch_2023_Putah_Creek_MARSS.R, published in support of:
## Baruch et al., 2024. "Mimicking Functional Elements of the Natural Flow Regime
## Promotes Native Fish Recovery in a Regulated River." https://doi.org/10.1002/eap.3013.

model_list_file = "single cov MARSS models.rds"
coef_tab_file = "single cov marss coefs.csv"
aicc_tab_file = "single cov MARSS AICc tab.csv"

# extract season abbreviations from predictors
preds_season_list = strsplit(x = preds_screened, split = "_")
preds_season = unlist(lapply(X = preds_season_list, function(x){x[1]}))

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  coef_tab = read.csv(file.path(data_dir, coef_tab_file))

} else {
  # initialize results storage: AICc and coefficient tables and list of models
  aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  coef_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
  colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
  colnames(coef_tab)=yvlt$y_val; rownames(coef_tab)=preds_screened
  
  list_of_mods = list()
  
  for(i in c(1,2)){ #for coho and chinook juv/adult ratios 
    y_val_i = yvlt$y_val[i]
    # only run models for seasons that effect the selected ecological (y) value
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]
    
    # for each predictor in metrics_screened tab,
    for(j in 1:length(preds_for_y)){ 
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){ # there can be no missing covariate values
        # pull y-value table from metrics_tab
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        # fit a MARSS model (with the predictor as a single covariate) 
        marss_mod = get_single_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                       pred = pred_j)
        # add to list of models
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        # print(paste(y_val_i, "on", pred_j)) # track progress
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        coef_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        
      }
      
    }
  }
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))

  aicc_tab$pred = row.names(aicc_tab)
  coef_tab$pred = row.names(coef_tab)
  
  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(coef_tab, file.path(data_dir, coef_tab_file), row.names = F)
}

# for(y_val in yvlt$y_val){
#   # view predictors in order of AICc value (smallest first)
#   results_y = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
#   results_y$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
#   results_y$coef = round(coef_tab[order(aicc_tab[,y_val]), y_val], 3)
# 
#   # aicc_y[,y_val] = round(aicc_y[,y_val], 2)
#   # coef_y = coef_tab[order(aicc_tab[,y_val]),c("pred",y_val)]
#   # coef_y[,y_val] = round(coef_y[,y_val], 3)
#   print(y_val)
#   print(head(results_y))
# 
#   print("")
# }

```

```{r MARSSSingleCovarTableCoho, echo = F, warning =F, results = 'asis'}

aicc_order_co = order(aicc_tab[,y_val_coho])
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[aicc_order_co, "pred"])
results_y_co$coef = round(coef_tab[aicc_order_co, y_val_coho], 3)
results_y_co$aicc = round(aicc_tab[aicc_order_co, y_val_coho], 2)
colnames(results_y_co) = c("Covariate", "Coefficient", "AICc")
# make table for display
results_y_co_ft = results_y_co
didnt_model = is.na(results_y_co_ft$AICc)
results_y_co_ft$AICc[didnt_model] = "--"; results_y_co_ft$Coefficient[didnt_model] = "--"

caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_coho], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")

coco_tab_ft = flextable(data=results_y_co_ft)
coco_tab_ft = set_caption(coco_tab_ft, caption = caption_text)
coco_tab_ft = flextable::width(coco_tab_ft,j=1,  width = 2)
coco_tab_ft = flextable::width(coco_tab_ft,j=2,  width = 1)
coco_tab_ft = flextable::width(coco_tab_ft,j=3,  width = 1)
coco_tab_ft


```


```{r MARSSSingleCovarTableChinook, echo = F, results = 'asis'}

aicc_order_ch = order(aicc_tab[,y_val_chinook])
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[aicc_order_ch, "pred"])
results_y_ch$coef = round(coef_tab[aicc_order_ch, y_val_chinook], 3)
results_y_ch$aicc = round(aicc_tab[aicc_order_ch, y_val_chinook], 2)
colnames(results_y_ch) = c("Covariate", "Coefficient", "AICc")
season_abbrev = substr(x = results_y_ch$Covariate, start = 1, stop = 2)
# make table for display
results_y_ch_ft = results_y_ch[!(season_abbrev %in% c("d2", "f2", "w2", "s2")),] # exclude predictors that don't temporally affect chinook smolt
didnt_model = is.na(results_y_ch_ft$AICc)
results_y_ch_ft$AICc[didnt_model] = "--"; results_y_ch_ft$Coefficient[didnt_model] = "--"


caption_text = paste0("Each row corresponds to a MARSS model predicting the time series of ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " observations using itself (up to time t) and one hydrologic metric covariate. Coefficient sign and value indicate the direction and strength of the influence of the hydrologic metric; i.e., a negative coefficient for hydrologic metric f1_recon_120 indicates that an earlier first fall river reconnection (120 cfs) is associated with a greater ", yvlt$y_val_title[yvlt$y_val==y_val_chinook], " value. Models are listed in order from best (lowest AICc value) to worst.  Values marked with -- indicate that gaps in the time series for the hydrologic metric prevented the calculation of a model using that covariate.")


coch_tab_ft = flextable(data=results_y_ch_ft)
coch_tab_ft = set_caption(coch_tab_ft, caption = caption_text)
coch_tab_ft = flextable::width(coch_tab_ft,j=1,  width = 2)
coch_tab_ft = flextable::width(coch_tab_ft,j=2,  width = 1)
coch_tab_ft = flextable::width(coch_tab_ft,j=3,  width = 1)
coch_tab_ft = flextable::set_header_labels(coch_tab_ft,
                                           values = list(
                                             Predictor ="Predictor", 
                                             Value = "Value",
                                             Description = "Greater Hydrologic Benefit value associated with"))
coch_tab_ft



```

```{r MARSSSingleCovars, echo = F, warning = F, fig.height = 8, fig.cap = "Results of the three best single-hydrologic-covariate MARSS models to predict log-transformed Chinook and coho outcomes with Z-scored hydrologic metrics.\\label{fig:MARSSSingleCovars}"}

n_mods = 3# for plot
top_cov_co = results_y_co$Covariate[order(results_y_co$AICc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_coho]))
pred_yrs_i_co = min(yrs_with_data):max(yrs_with_data)

top_cov_ch = results_y_ch$Covariate[order(results_y_ch$AICc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data = which(!is.na(metrics_tab[,y_val_chinook]))
pred_yrs_i_ch = min(yrs_with_data):max(yrs_with_data)


fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_co,
                                   y_val = y_val_coho, top_cov = top_cov_co,
                                   top_models = top_mods_co)

  marss_predict_plot_single_covars(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_ch,
                                   y_val = y_val_chinook, top_cov = top_cov_ch,
                                   top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```


<!-- ```{r MARSSSingleCovarPredictChinook, echo = F, warning = F, fig.height = 8, fig.cap = "Results of MARSS to predict log-transformed Chinook outcomes with Z-scored hydrologic metrics.\\label{fig:MARSSSingleCovarPredictChinook}"} -->

<!-- top_3_cov = results_y$Covariate[order(results_y$AICc)][1:3] -->

<!-- par(mfrow = c(3,1)) -->
<!-- for(j in 1:3){ -->
<!--   pred_j = top_3_cov[j] -->
<!--   mod_name = paste0(y_val_chinook, "__", pred_j) -->
<!--   mod_j = list_of_mods[[mod_name]] -->
<!--   names(list_of_mods) -->

<!--   prediction = predict(mod_j, type = "ytt") -->
<!-- plot(prediction, main = pred_j) -->
<!-- } -->


<!-- ``` -->


### MARSS models, two covariates (spawner abundance and one hydrologic)

As another technique, we could attempt to model observed juvenile abundance using each hydrologic metric paired with the observed spawner abundance among the parents of a given cohort.

```{r MARSS2RegYVal, echo = F}
predict_eco = "juvenile abundance, hydro and spawners"
# Hydro-only predictors
if(predict_eco == "juveniles per spawner"){y_val_chinook = "chinook_juv_per_adult"; y_val_coho = "coho_smolt_per_fem"}
# if(predict_eco == "juvenile abundance, hydro only"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}
# Number of spawners included as predictor
if(predict_eco == "juvenile abundance, hydro and spawners"){y_val_chinook = "chinook_juvenile_abundance"; y_val_coho = "coho_smolt_abun_est"}

```

```{r newMetricsTabForMARSS2, echo = F}

metrics_tab = calc_metrics_hydro_by_affected_brood_year(
  hydro_by_brood_year = brood_year_hydro_tab,
  thresholds = thresh_for_corr_fig) 

# Clean metrics tab:
# 1) factorize water year category
metrics_tab$wy1_WY_Cat = as.numeric(factor(metrics_tab$wy1_WY_Cat,
                                   levels = c("dry year", "mod year", "wet year")))
metrics_tab$wy2_WY_Cat = as.numeric(factor(metrics_tab$wy2_WY_Cat,
                                   levels = c("dry year", "mod year", "wet year")))


yvlt = y_val_label_tab()
non_preds = c("brood_year", "smolt_year", yvlt$y_val)


if(zscore_flow_metrics == T){
  zscore_these = !(colnames(metrics_tab) %in% non_preds)
  metrics_mean = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = mean, na.rm=T)
  metrics_sd = apply(X = metrics_tab[,zscore_these], MARGIN = 2, FUN = sd, na.rm=T)
  metrics_tab[,zscore_these] = apply(X = metrics_tab[,zscore_these],
                                     MARGIN = 2, FUN = zscore_column_na_rm)
  
  if(predict_eco == "juvenile abundance, hydro and spawners"){
      # add spawners as a z-scored predictor variable
  metrics_tab$coho_spawners_zscored =
    zscore_column_na_rm(x = metrics_tab$coho_spawner_abundance)
  metrics_tab$chinook_spawners_zscored =
    zscore_column_na_rm(x = metrics_tab$chinook_spawner_abundance)
  non_preds = c(non_preds, "coho_spawners_zscored", "chinook_spawners_zscored")

  }
}

  # transform data
  if(log_transform_eco_metrics == T){
    metrics_tab[,yvlt$y_val] = log10(metrics_tab[,yvlt$y_val])
  }



```



```{r MARSS_models_flow_and_spawn_covar, echo = F}

model_list_file = "flow and spawn MARSS models.rds"
flow_tab_file = "flow and spawn marss coefs_flow.csv"
spawn_tab_file = "flow and spawn marss coefs_spawn.csv"
aicc_tab_file = "flow and spawn AICc tab.csv"

if(file.exists(file.path(data_dir, model_list_file))){
  list_of_mods = readRDS(file.path(data_dir, model_list_file))
  aicc_tab = read.csv(file.path(data_dir, aicc_tab_file))
  flow_tab = read.csv(file.path(data_dir, flow_tab_file))
  spawn_tab = read.csv(file.path(data_dir, spawn_tab_file))

} else {

aicc_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
flow_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
spawn_tab = data.frame(matrix(data=NA, nrow=length(preds_screened), ncol = length(yvlt$y_val)))
colnames(aicc_tab)=yvlt$y_val; rownames(aicc_tab)=preds_screened
colnames(flow_tab)=yvlt$y_val; rownames(flow_tab)=preds_screened
colnames(spawn_tab)=yvlt$y_val; rownames(spawn_tab)=preds_screened


  smolts = c("coho_smolt_abun_est", "chinook_juvenile_abundance")
  spawns =  c("coho_spawners_zscored", "chinook_spawners_zscored")
  for(i in 1:2){
    y_val_i = smolts[i]
    y_val_spawn = spawns[i]
    # y_val_i = yvlt$y_val[smolts_i]
    # x_val_spawn = yvlt$y_val[spawn_i]
    y_seasons = unlist(strsplit(yvlt$influencing_seasons[yvlt$y_val==y_val_i],", "))
    preds_for_y = preds_screened[preds_season %in% y_seasons]

    for(j in 1:length(preds_for_y)){
      pred_j = preds_for_y[j]
      if(sum(is.na(metrics_tab[,pred_j]))<1){
        y_obs_tab = get_obs_data_for_MARSS(metrics_tab = metrics_tab,
                                           y_val_names = y_val_i)
        marss_mod = get_flow_and_spawn_cov_model_fit_for_MARSS(y_obs_tab = y_obs_tab,
                                                               y_spawn_colname = y_val_spawn,
                                                               pred = pred_j)
        list_of_mods[[length(list_of_mods)+1]] = marss_mod
        names(list_of_mods)[length(list_of_mods)] = paste0(y_val_i, "__", pred_j)
        
        row_finder = match(pred_j, row.names(aicc_tab))
        aicc_tab[row_finder, y_val_i] = marss_mod$AICc
        flow_tab[row_finder, y_val_i] = marss_mod$coef["C.ScottR"]
        spawn_tab[row_finder, y_val_i] = marss_mod$coef["C.Spawners"]
        
      }
      # print(paste(y_val_i, "on", pred_j))
      # par(mfrow = c(4,2))
      # plot(marss_mod)
      
              # print(paste(y_val_i, "on", pred_j)) # track progress

    }
  }
  
  aicc_tab$pred = row.names(aicc_tab)
  flow_tab$pred = row.names(flow_tab)  
  spawn_tab$pred = row.names(spawn_tab)
  
  saveRDS(object = list_of_mods, 
          file = file.path(data_dir,model_list_file))

  write.csv(aicc_tab, file.path(data_dir, aicc_tab_file), row.names = F)
  write.csv(flow_tab, file.path(data_dir, flow_tab_file), row.names = F)
  write.csv(spawn_tab, file.path(data_dir, spawn_tab_file), row.names = F)
}

# 
#   for(i in 1:2){
#     y_val = yvlt$y_val[smolts_is[i]]
#     # view predictors in order of AICc value (smallest first)
#     results_y = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
#     results_y$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
#     results_y$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
#     results_y$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 3)
# 
#     # aicc_y[,y_val] = round(aicc_y[,y_val], 2)
#     # coef_y = coef_tab[order(aicc_tab[,y_val]),c("pred",y_val)]
#     # coef_y[,y_val] = round(coef_y[,y_val], 3)
#     print(y_val)
#     print(head(results_y))
# 
#     print("")
#   }

```


```{r MARSS_flow_and_spawn_covar_table_co, echo = F}

y_val = "coho_smolt_abun_est"
# view predictors in order of AICc value (smallest first)
results_y_co = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
results_y_co$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
results_y_co$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_co$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_co$HtoSratio = round(results_y_co$flow / results_y_co$spawn,1)


afs_co_tab_ft = flextable(data=results_y_co)
caption_text = paste0("Characteristics of MARSS models of", yvlt$y_val_title[yvlt$y_val==y_val], "using one hydrologic metric as the single covariate in each model.")


afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=1,  width = 2.5)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=3,  width = 1)
afs_co_tab_ft = flextable::width(afs_co_tab_ft,j=4,  width = 1)
afs_co_tab_ft = flextable::set_header_labels(afs_co_tab_ft,
                                           values = list(
                                             pred = "Hydrologic Covariate",
                                             aicc = "AICc",
                                             flow ="Hydro Coef.",
                                             spawn = "Spawner Coef."))
afs_co_tab_ft
```


```{r MARSS_flow_and_spawn_covar_table_ch, echo = F}
y_val = "chinook_juvenile_abundance"
# view predictors in order of AICc value (smallest first)
results_y_ch = data.frame(pred = aicc_tab[order(aicc_tab[,y_val]), "pred"])
results_y_ch$aicc = round(aicc_tab[order(aicc_tab[, y_val]), y_val], 2)
results_y_ch$flow = round(flow_tab[order(aicc_tab[,y_val]), y_val], 3)
results_y_ch$spawn = round(spawn_tab[order(aicc_tab[,y_val]), y_val], 4)
results_y_ch$HtoS_ratio = round(results_y_ch$flow / results_y_ch$spawn,1)


afs_ch_tab_ft = flextable(data=results_y_ch)
caption_text = paste0("Characteristics of MARSS models of", yvlt$y_val_title[yvlt$y_val==y_val], "using one hydrologic metric as the single covariate in each model.")
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=1,  width = 2.5)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=3,  width = 1)
afs_ch_tab_ft = flextable::width(afs_ch_tab_ft,j=4,  width = 1)
afs_ch_tab_ft = flextable::set_header_labels(afs_ch_tab_ft,
                                           values = list(
                                             pred = "Hydrologic Covariate",
                                             aicc = "AICc",
                                             flow ="Hydro Coef.",
                                             spawn = "Spawner Coef."))

afs_ch_tab_ft
```

```{r MARSSHydroPlusSpawn, echo = F, warning = F, fig.height = 8, fig.cap = "Results of MARSS to predict log-transformed Chinook outcomes with Z-scored hydrologic metrics plus spawner data.\\label{fig:MARSSHydroPlusSpawn}"}

n_mods = 3# for plot
top_cov_co = results_y_co$pred[order(results_y_co$aicc)][1:n_mods]
top_mods_co = list_of_mods[paste0(y_val_coho, "__", top_cov_co)]
yrs_with_data_yval = which(!is.na(metrics_tab[,y_val_coho]))
yrs_with_data_spawn = which(!is.na(metrics_tab[,"coho_spawners_zscored"]))
pred_yrs_i_co = min(yrs_with_data_spawn):max(yrs_with_data_yval)

top_cov_ch = results_y_ch$pred[order(results_y_ch$aicc)][1:n_mods]
top_mods_ch = list_of_mods[paste0(y_val_chinook, "__", top_cov_ch)]
yrs_with_data_yval = which(!is.na(metrics_tab[,y_val_chinook]))
yrs_with_data_spawn = which(!is.na(metrics_tab[,"chinook_spawners_zscored"]))
pred_yrs_i_ch = min(yrs_with_data_spawn):max(yrs_with_data_yval)


fig_path = file.path(save_figs_here, paste0("Figure ",fig_i,".png"))
if(save_imgs == TRUE){
  png(filename = fig_path, width = 7, height = 8, units = "in", res = res_dpi)
  
  par(mfrow = c(2,1))
  marss_predict_plot_flow_and_spawn(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_co,
                                   y_val = y_val_coho, 
                                   top_cov = top_cov_co,
                                   top_models = top_mods_co)

  marss_predict_plot_flow_and_spawn(metrics_tab = metrics_tab,
                                   pred_yrs_i = pred_yrs_i_ch,
                                   y_val = y_val_chinook, 
                                   top_cov = top_cov_ch,
                                   top_models = top_mods_ch)  
  
  dev.off()
}
if(include_figs==T){knitr::include_graphics(fig_path)}
fig_i = fig_i +1


```




# References
